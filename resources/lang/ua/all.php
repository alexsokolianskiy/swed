<?php
return [
"titlename" =>"RELDES",
"experiments" =>"Експерименти",
"experiment" =>"Експеримент",
"led" =>"Cвітлодіоди",
"servo" =>"Сервопривод",
"distance" =>"Датчик відстанні",
"display" =>"Дісплей",
'platforms' =>"Платформи",
"recommendation" =>"Рекомендаційна система",
"recommendation_over" =>"Опис",
"recommendation_select" =>"Вибір платформи",
'sh' =>"Розумний будинок та Інтернет речей",
'solar_station' =>"Сонячна станція",
'lighting' =>"Контроль освітленості",
'climate' =>"Клімат-контроль",
'access' =>"Контроль доступу",
'security' =>"Контроль безпеки",
'zone' =>"Контроль зони",
'presence' =>"Контроль присутності",
'ventilation' =>"Вентиляція",
'illumination' =>"Керування освітленням",

"slide1" =>"Реєстрація",
"slide1_desc" =>"Для отримання доступу до експериментів необхідно пройти реєстрацію.",
"slide1_button" =>"Зареєструйтеся сьогодні",
"slide2" =>"Студентський проект.",
"slide2_desc" =>"Проект магістрів та аспірантів кафедри Програмних засобів Національного Університету «Запорізька Політехніка» (Zaporizhzhia National Polytechnic University).",
"slide3" =>"Вбудовані системи",
"slide3_desc" =>"Вбудовані системи сьогодні правлять світом. Використовуйте віддалену лабораторію для швидкого прототипування вбудованої системи.",

"cross" =>"Кросплатформність",
"cross_desc" =>"Використовуйте будь-який пристрій та операційну систему",
"conf" =>"Конфігурований експеримент",
"conf_desc" =>"Створюйте свій програмний код або використовуйте шаблони",
"simpl" =>"Простота доступу",
"simpl_desc" =>"Використовуйте наше обладнання – заощаджуйте гроші",
"reldes" =>"Віддалена лабораторія",
"reldes_desc" =>"RELDES (REmote Laboratory for Design of Embedded Systems) ‑ віддалена лабораторія проектування вбудованих систем, розроблена на кафедрі програмних засобів Національного Університету «Запорізька Політехніка» (Zaporizhzhia National Polytechnic University). Надає віддалений доступ до експериментального обладнання на основі платформ Arduino.",
"field" =>"Область застосування",
"field_desc" =>"Підтримка прийняття проектних рішень при проектуванні вбудованих систем управління рухомими об'єктами на основі мікроконтролерів.",
"target" =>"Цільова аудиторія",
"target_desc" =>"Студенти, викладачі та розробники в галузі проектування вбудованих систем.",
"functional" =>"Функціональні можливості",
"functional_desc" =>"Лабораторія надає користувачам інформацію про програмні та апаратні компоненти для подальшого впровадження в реальних проектах, дозволяє отримати навички програмування вбудованих систем.",

"univer" =>"НУ «Запорізька політехніка»",
"to_top" =>"До початку",

"log_in" =>"Вхід",
"exit" =>"Вихід",
"login" =>"логін",
"passwd" =>"пароль",
"passwd_repeat" => "повторіть пароль",
"auth" =>"Авторизація",
"close" =>"Закрити",

"uno_info" =>"Загальні відомості",
"uno_info_desc" =>"Arduino Uno побудовано на базі мікроконтролера ATmega328 (<a target=> '_blank' href=> 'http://www.atmel.com/Images/doc8161.pdf'>технічний опис, pdf</a>). Платформа має 14 цифрових входів/виходів (з котрих 6 можуть також працювати як входи ШІМ), 6 аналогових входів, кварцовий генератор 16 МГц, роз’єм USB та ICSP, силовий роз’єм, та кнопку перезавантаження. Для роботи необхідно підключити платформу до комп’ютеру за допомогою кабелю USB, або підключити живлення за допомогою адаптера AC/DC або батарей",
"uno_summary" =>"
	<tr><td>Мікроконтролер</td><td>ATmega328</td></tr>
	<tr><td>Робоча напруга</td><td>5В</td></tr>
	<tr><td>Вхідна напруга (рекомендована)</td><td>7-12В</td></tr>
	<tr><td>Вхідна напруга (максимальна)</td><td>6-20В</td></tr>
	<tr><td>Цифрові Входи/Виходи</td><td>14 (з котрих 6 можуть також працювати як входи ШІМ)</td></tr>
	<tr><td>Аналогові входи</td><td>6</td></tr>
	<tr><td>Постійний струм через вхід/вихід</td><td>40 мА</td></tr>
	<tr><td>Постійний струм для 3.3В виводу</td><td>50 мА</td></tr>
	<tr><td>Флеш-пам’ять</td><td>32 КБ (з котрих 0.5 КБ використовуються для завантажувача програм)</td></tr>
	<tr><td>ОЗП</td><td>2 КБ</td></tr>
	<tr><td>Енергонезалежна пам’ять</td><td>1 КБ</td></tr>
	<tr><td>Тактова частота</td><td>16 МГц</td></tr>",
"uno_extra" =>"Характеристики",
"uno_extra_desc" =>"
	<div class=\"spoiler-body collapse\">
	<h4>Живлення</h4>
	<p>
		Arduino Uno може отримувати живлення як через підключення по USB, так і від зовнішнього джерела живлення. Джерело живлення вибирається автоматично.
	</p>
	<p>
		Зовнішнє живлення (не USB) може подаватися через перетворювач напруги AC/DC (блок живлення) або акумуляторною батареєю. Перетворювач напруги підключається за допомогою роз’єму 2.1 мм з позитивним полюсом на центральному контакті. Дроти від батареї підключаються до виводів Gnd і Vin.
	</p>
	<p>
		Платформа може працювати при зовнішньому живленні від 6 В до 20 В. При напрузі живлення нижче 7 В, вивід 5V може видавати менше 5 В, при цьому платформа може працювати нестабільно. При використанні напруги вище 12 В регулятор напруги може перегрітися і пошкодити плату. Рекомендований діапазон від 7 В до 12 В.
	</p>
	<p>
		Виводи живлення:
		<ul>
			<li><strong>VIN.</strong> Вхід використовується для подачі живлення від зовнішнього джерела (за відсутності 5 В від роз’єму USB або іншого регульованого джерела живлення). Подача напруги живлення відбувається через даний вивід. Якщо харчування подається на роз'єм 2.1мм, то VIN можна використовувати для отримання живлення.</li>
			<li><strong>5V.</strong> Регульоване джерело напруги, що використовується для живлення мікроконтролера і компонентів на платі. Живлення може подаватися від виведення VIN через регулятор напруги, або від роз’єму USB, або іншого регульованого джерела напруги 5 В.</li>
			<li><strong>3V3.</strong> Напруга на виводі 3.3 В генерується мікросхемою FTDI на платформі. Максимальне споживання струму 50 мА.</li>
			<li><strong>GND.</strong> Виводи заземлення.</li>
		</ul>
	</p>
	<h4>Пам’ять</h4>
	<p>
		Мікроконтролер ATmega328 має 32 кБ флеш пам’яті, з яких 0.5 кБ використовується для зберігання завантажувача, а також 2 кБ ОЗП (SRAM) і 1 Кб EEPROM (читання і запис виконується за допомогою бібліотеки EEPROM).
	</p>
	<h4>Входи і виходи</h4>
	<p>
		Кожен з 14 цифрових виводів Uno може бути налаштований як вхід або вихід, використовуючи функції pinMode (), digitalWrite (), і digitalRead (),. Виводи працюють при напрузі 5 В. Кожен вивід має навантажувальний резистор (за замовчуванням відключений) 20-50 кОм і може пропускати до 40 мА. Деякі виводи мають особливі функції:
		<ul>
			<li><strong>Послідовна шина: 0 (RX) і 1 (TX).</strong> Виводи використовуються для отримання (RX) і передачі (TX) даних TTL. Дані виводи підключені до відповідних ніжок мікросхеми послідовної шини ATmega8U2 USB-to-TTL.</li>
			<li><strong>Зовнішнє переривання: 2 і 3.</strong> Дані виводи можуть бути налаштовані на виклик переривання або на молодшому значенні, або на передньому чи задньому фронті, або при зміні значення. Детальна інформація знаходиться в описі функції attachInterrupt ().</li>
			<li><strong>ШІМ: 3, 5, 6, 9, 10, і 11.</strong> Будь-який з виводів забезпечує ШІМ з роздільною здатністю 8 біт за допомогою функції analogWrite ().</li>
			<li><strong>SPI: 10 (SS), 11 (MOSI), 12 (MISO), 13 (SCK).</strong> За допомогою даних виводів здійснюється зв’язок SPI, для чого використовується бібліотека SPI.</li>
			<li><strong>LED: 13.</strong>Вбудований світлодіод, підключений до цифрового виводу 13. Якщо значення на виході має високий потенціал, то світлодіод горить.</li>
			<li><strong>I2C: 4 (SDA) та 5 (SCL).</strong> За допомогою виводів здійснюється зв’язок I2C (TWI), для створення якого використовується бібліотека Wire.</li>
		</ul>
		<p>
			На платформі Uno встановлені 6 аналогових входів (позначених як A0 .. A5), кожен з роздільною здатністю 10 біт (тобто може приймати 1024 різних значення). За замовчанням виводи мають діапазон вимірювання до 5 В щодо землі, проте є можливість змінити верхню межу за допомогою виведення AREF і функції analogReference ().
		</p>
		<p>
			 Додаткова пара виводів платформи:
			<ul>
				<li><strong>AREF.</strong> Опорна напруга для аналогових входів. Використовується з функцією analogReference ().</li>
				<li><strong>Reset.</strong> Низький рівень сигналу на виводі перезавантажує мікроконтролер. Зазвичай застосовується для підключення кнопки перезавантаження на платі розширення, що закриває доступ до кнопки на самій платі Arduino.</li>
			</ul>
		</p>
		<h4>Зв’язок</h4>
		<p>
		На платформі Arduino Uno встановлено кілька пристроїв для здійснення зв’язку з комп’ютером, іншими пристроями Arduino або мікроконтролерами. ATmega328 підтримують послідовний інтерфейс UART TTL (5 В), який здійснюється виводами 0 (RX) і 1 (TX).
		Встановлена на платі мікросхема ATmega8U2 направляє даний інтерфейс через USB; програми на стороні комп’ютера \"спілкуються\" з платою через віртуальний COM порт. Прошивка ATmega8U2 використовує стандартні драйвера USB COM, ніяких сторонніх драйверів не потрібно, але на Windows для підключення потрібно файл ArduinoUNO.inf. Моніторинг послідовної шини (Serial Monitor) програми Arduino дозволяє посилати і отримувати текстові дані при підключенні до платформи. Світлодіоди RX і TX на платформі будуть мерехтіти при передачі даних через мікросхему FTDI або USB підключення (але не при використанні послідовної передачі через виводи 0 і 1).
		</p>
		<p>
		Бібліотекою SoftwareSerial можливо створити послідовну передачу даних через будь-який з цифрових виводів Uno.
		</p>
		<p>
		ATmega328 підтримує інтерфейси I2C (TWI) і SPI. В Arduino включена бібліотека Wire для зручності використання шини I2C.
		</p>
		<h4>Програмування</h4>
		<p>
		Платформа програмується за допомогою ПЗ Arduino. Детальна інформація знаходиться в довіднику та інструкціях.
		</p>
		<p>
			 Микроконтроллер ATmega328 поставляется с записанным загрузчиком, облегчающим запись новых программ без использования внешних программаторов. Связь осуществляется оригинальным протоколом STK500.
		</p>
		<p>
			Є можливість не використовувати завантажувач і запрограмувати мікроконтролер через виводи ICSP (внутрішньосхемне програмування).
		</p>
		<p>
		Код прошивки для контролера ATmega8U2 є у вільному доступі в мережі Інтернет. Контролер ATmega8U2 має власний DFU завантажувач, який може бути активований замиканням джампера на звороті плати (поруч з картою Італії) і перезавантаженням контролера. Для запису нової прошивки можливо використовувати Atmel's FLIP (під Windows) або DFU програматор (на Mac OS X або Linux). Також можна переписати програму зовнішнім програматором, використовуючи ISP вхід.
		</p>
		<h4>Автоматичне (програмне) перезавантаження</h4>
		<p>
		Uno розроблена таким чином, щоб перед записом нового коду перезавантаження здійснювалася самою програмою Arduino на комп’ютері, а не натисканням кнопки на платформі. Одна з ліній DTR мікросхеми ATmega8U2, керуючих потоком даних (DTR), підключена до виводу перезавантаження мікроконтролеру ATmega328 через 100 нФ конденсатор. Активація даної лінії, тобто подача сигналу низького рівня, перезавантажує мікроконтролер. Програма Arduino, використовуючи цю функцію, завантажує код одним натисканням кнопки Upload в самому середовищі програмування. Подача сигналу низького рівня по лінії DTR скоординована з початком запису коду, що скорочує таймаут завантажувача.
		</p>
		<p>
		Функція має ще одне застосування. Перезавантаження Uno відбувається кожного разу при підключенні до програми Arduino на комп’ютері з ОС Mac X або Linux (через USB). Наступні пів секунди після перезавантаження працює завантажувач. Під час програмування відбувається затримка декількох перших байтів коду, щоб уникнути отримання платформою некоректних даних (всіх, окрім коду нової програми). Якщо виконується разове налагодження скетчу, записаного в платформу, або введення будь-яких інших даних при першому запуску, необхідно переконатися, що програма на комп’ютері очікує протягом секунди перед передачею даних.
		</p>
		<p>
		На Uno є можливість відключити лінію автоматичного перезавантаження розривом відповідної лінії. Контакти мікросхем з обох кінців лінії можуть бути з’єднані з метою відновлення. Лінія маркована «RESET-EN». Вимкнення автоматичного перезавантаження також можливо підключивши резистор 110 Ом між джерелом 5 В і даною лінією.
		</p>
		<h4>Струмовий захист роз’єму USB</h4>
		<p>
		В Arduino Uno вбудований запобіжник (який спрацьовує автоматично), що захищає порт USB комп’ютера від струмів короткого замикання і надструмів. Хоча практично всі комп’ютери мають подібний захист, тим не менш, цей запобіжник забезпечує додатковий бар’єр. Запобіжник спрацьовує при проходженні струму більше 500 мА через USB порт і розмикає ланцюг до тих пір поки нормальні значення струмів НЕ будуть відновлено.
		</p>
		<h4>Фізичні характеристики</h4>
		<p>
		Довжина і ширина друкованої плати Uno складають 6.9 і 5.3 см відповідно. Роз’єм USB і силовий роз’єм виходять за межі даних розмірів. Чотири отвори в платі дозволяють закріпити її на поверхні. Відстань між цифровими виводами 7 і 8 дорівнює 0,4 см, хоча між іншими виводами воно становить 0,25 см.
		</p>
	</div>",

"mega_info" =>"Загальні відомості",
"mega_info_desc" =>"Arduino Mega побудована на мікроконтролері ATmega2560 (<a target=> '_blank' href=> 'http://www.atmel.com/Images/Atmel-2549-8-bit-AVR-Microcontroller-ATmega640-1280-1281-2560-2561_datasheet.pdf'>технічний опис, pdf</a>). Плата має 54 цифрових входів/виходів (15 з яких можуть використовуватися як виходи ШІМ), 16 аналогових входів, 4 послідовних порту UART, кварцовий генератор 16 МГц, USB та ICSP роз’єм, роз’єм живлення і кнопка перезавантаження. Для роботи необхідно підключити платформу до комп’ютера за допомогою кабелю USB або подати живлення за допомогою адаптера AC/DC, або акумуляторною батареєю. Arduino Mega 2560 сумісна з усіма платами розширення, розробленими для платформ Uno або Duemilanove.",
"mega_summary" =>"
	<tr><td>Мікроконтролер</td><td>ATmega2560</td></tr>
	<tr><td>Робоча напруга</td><td>5В</td></tr>
	<tr><td>Вхідна напруга (рекомендована)</td><td>7-12В</td></tr>
	<tr><td>Вхідна напруга (максимальна)</td><td>6-20В</td></tr>
	<tr><td>Цифрові Входи/Виходи</td><td>54 (з котрих 15 можуть також працювати як входи ШІМ)</td></tr>
	<tr><td>Аналогові входи</td><td>16</td></tr>
	<tr><td>Постійний струм через вхід/вихід</td><td>40 мА</td></tr>
	<tr><td>Постійний струм для 3.3В виводу</td><td>50 мА</td></tr>
	<tr><td>Флеш-пам’ять</td><td>256 КБ (з котрих 8 КБ використовуються для завантажувача програм)</td></tr>
	<tr><td>ОЗП</td><td>8 КБ</td></tr>
	<tr><td>Енергонезалежна пам’ять	</td><td>4 КБ</td></tr>
	<tr><td>Тактова частота</td><td>16 МГц</td></tr>",
"mega_extra" =>"Характеристики",
"mega_extra_desc" =>"
	<div class=\"spoiler-body collapse\">
	<h4>Живлення</h4>
	<p>
	Arduino Mega може отримувати живлення як через підключення по USB, так і від зовнішнього джерела живлення. Джерело живлення вибирається автоматично.
	</p>
	<p>
	Зовнішнє живлення (не USB) може подаватися через перетворювач напруги AC/DC (блок живлення) або акумуляторною батареєю. Перетворювач напруги підключається за допомогою роз’єму 2.1 мм з позитивним полюсом на центральному контакті. Дроти від батареї підключаються до виводів Gnd і Vin.
	</p>
	<p>
		Платформа може працювати при зовнішньому живленні від 6 В до 20 В. При напрузі живлення нижче 7 В, вивід 5V може видавати менше 5 В, при цьому платформа може працювати нестабільно. При використанні напруги вище 12 В регулятор напруги може перегрітися і пошкодити плату. Рекомендований діапазон від 7 В до 12 В.
	</p>
	<p>
		Виводи живлення:
		<ul>
			<li><strong>VIN.</strong> Вхід використовується для подачі живлення від зовнішнього джерела (за відсутності 5 В від роз’єму USB або іншого регульованого джерела живлення). Подача напруги живлення відбувається через даний вивід. Якщо харчування подається на роз'єм 2.1мм, то VIN можна використовувати для отримання живлення.</li>
			<li><strong>5V.</strong> Регульоване джерело напруги, що використовується для живлення мікроконтролера і компонентів на платі. Живлення може подаватися від виведення VIN через регулятор напруги, або від роз’єму USB, або іншого регульованого джерела напруги 5 В.</li>
			<li><strong>3V3.</strong> Напруга на виводі 3.3 В генерується мікросхемою FTDI на платформі. Максимальне споживання струму 50 мА.</li>
			<li><strong>GND.</strong> Виводи заземлення.</li>
		</ul>
	</p>
	<h4>Пам’ять</h4>
	<p>
	Мікроконтролер ATmega2560 має 256 кБ флеш пам’яті для зберігання коду програми (з яких 4 кБ використовується для зберігання завантажувача), 8 кБ ОЗП (SRAM) і 4 Кб EEPROM (читання і запис виконується за допомогою бібліотеки EEPROM).
	</p>
	<h4>Входи і виходи</h4>
	<p>
	Кожен з 54 цифрових виводів Uno може бути налаштований як вхід або вихід, використовуючи функції pinMode (), digitalWrite (), і digitalRead (),. Виводи працюють при напрузі 5 В. Кожен вивід має навантажувальний резистор (за замовчуванням відключений) 20-50 кОм і може пропускати до 40 мА. Деякі виводи мають особливі функції:
		<ul>
			<li><strong>Послідовна шина: 0 (RX) і 1 (TX); Послідовна шина 1: 19 (RX) і 18 (TX); Послідовна шина 2: 17 (RX) і 16 (TX); Послідовна шина 3: 15 (RX) і 14 (TX); Виводи використовуються для отримання (RX) і передачі (TX) даних TTL. Виводи 0 та 1 підключені до відповідних ніжок мікросхеми послідовної шини ATmega8U2.</li>
			<li><strong>Зовнішнє переривання: 2 (переривання 0), 3 (переривання 1), 18 (переривання 5), 19 (переривання 4), 20 (переривання 3), та 21 (переривання 2). Ці виводи можуть бути налаштовані на виклик переривання або на молодшому значенні, або на передньому чи задньому фронті, або при зміні значення. Детальна інформація знаходиться в описі функції attachInterrupt().</li>
			<li><strong>ШІМ: 2 до 13, та 44-46. Будь-який з виводів забезпечує ШІМ з роздільною здатністю 8 біт за допомогою функції analogWrite ().</li>
			<li><strong>SPI: 50 (SS), 51 (MOSI), 52 (MISO), 53 (SCK). За допомогою даних виводів здійснюється зв’язок SPI, для чого використовується бібліотека SPI. Також виводи SPI можуть бути виведені до блоку ICSP, котрий сумісний с платформами Uno, Duemilanove и Diecimila.</li>
			<li><strong>LED: 13. Вбудований світлодіод, підключений до цифрового виводу 13. Якщо значення на виході має високий потенціал, то світлодіод горить.</li>
			<li><strong>I2C: 20 (SDA) та 21 (SCL). За допомогою виводів здійснюється зв’язок I2C (TWI). Для створення якого використовується бібліотека Wire (інформація на сайті Wiring). Розміщення виводів на платформі Mega не відповідає розміщенню Duemilanove або Diecimila.</li>
		</ul>
		<p>
		На платформі Mega2560 є 16 аналогових входів, кожен з роздільною здатністю 10 біт (тобто може приймати 1024 різних значення). За замовчанням виводи мають діапазон вимірювання до 5 В щодо землі, проте є можливість змінити верхню межу за допомогою виведення AREF і функції analogReference ().
		</p>
		<p>
		Додаткова пара виводів платформи:
			<ul>
				<li><strong>AREF.</strong>Опорна напруга для аналогових входів. Використовується з функцією analogReference ().</li>
				<li><strong>Reset.</strong> Низький рівень сигналу на виводі перезавантажує мікроконтролер. Зазвичай застосовується для підключення кнопки перезавантаження на платі розширення, що закриває доступ до кнопки на самій платі Arduino.</li>
			</ul>
		</p>
		<h4>Зв’язок</h4>
		<p>
		На платформі Arduino Mega2560 встановлено кілька пристроїв для здійснення зв’язку з комп’ютером, іншими пристроями Arduino або мікроконтролерами. ATmega2560 підтримують послідовний інтерфейс UART для TTL. Встановлена на платі мікросхема ATmega8U2 направляє один з інтерфейсів через USB, надаючи віртуальний COM порт програмам на комп’ютері (на Windows для підключення потрібно файл ArduinoUNO.inf, системи OSX и Linux автоматично розпізнають COM порт). Утиліта моніторингу послідовної шини (Serial Monitor) середовища розробки Arduino дозволяє посилати і отримувати текстові дані при підключенні до платформи. Світлодіоди RX і TX на платформі будуть мерехтіти при передачі даних через мікросхему ATmega8U2 або USB підключення (але не при використанні послідовної передачі через виводи 0 і 1).
		</p>
		<p>
		Бібліотекою SoftwareSerial можливо створити послідовну передачу даних через будь-який з цифрових виводів Mega2560.
		</p>
		<p>
		ATmega2560 підтримує інтерфейси I2C (TWI) і SPI. В Arduino включена бібліотека Wire для зручності використання шини I2C. Більш детальна інформація знаходиться на сайті Wiring. Для зв’язку по SPI, використовується бібліотека SPI.
		</p>
		<h4>Програмування</h4>
		<p>
		Платформа програмується за допомогою середовища розробки Arduino. Детальна інформація знаходиться в довіднику та інструкціях.
		</p>
		<p>
		Мікроконтролер ATmega2560 поставляється з записаним завантажувачем, що полегшує завантаження нових програм без використання зовнішніх програматорів. Зв’язок здійснюється оригінальним протоколом STK500.
		</p>
		<p>
		Є можливість не використовувати завантажувач і запрограмувати мікроконтролер через виводи ICSP (внутрішньосхемне програмування). Детальна інформація знаходиться у цій інструкції.
		</p>
		<p>
		Контролер ATmega8U2 має власний DFU завантажувач, який може бути активований замиканням джампера на звороті плати (поруч з картою Італії) і перезавантаженням контролера. Для запису нової прошивки можливо використовувати Atmel's FLIP (під Windows) або DFU програматор (на Mac OS X або Linux). Також можна переписати програму зовнішнім програматором, використовуючи ISP вхід.
		</p>
		<h4>Автоматичне (програмне) перезавантаження</h4>
		<p>
		Mega розроблена таким чином, щоб перед записом нового коду перезавантаження здійснювалася самою програмою Arduino на комп’ютері, а не натисканням кнопки на платформі. Одна з ліній ATmega8U2, керуючих потоком даних (DTR), підключена до виводу перезавантаження мікроконтролеру ATmega2560 через  конденсатор 100 нФ. Активація даної лінії, тобто подача сигналу низького рівня, перезавантажує мікроконтролер. Програма Arduino, використовуючи цю функцію, завантажує код одним натисканням кнопки Upload в самому середовищі програмування. Подача сигналу низького рівня по лінії DTR скоординована з початком запису коду, що скорочує таймаут завантажувача.
		</p>
		<p>
		Функція має ще одне застосування. Перезавантаження Mega2560 відбувається кожного разу при підключенні до програми Arduino на комп’ютері з ОС Mac X або Linux (через USB). Наступні пів секунди після перезавантаження працює завантажувач. Під час програмування відбувається затримка декількох перших байтів коду, щоб уникнути отримання платформою некоректних даних (всіх, окрім коду нової програми). Якщо виконується разове налагодження скетчу, записаного в платформу, або введення будь-яких інших даних при першому запуску, необхідно переконатися, що програма на комп’ютері очікує протягом секунди перед передачею даних.
		</p>
		<p>
		На Mega2560 є можливість відключити лінію автоматичного перезавантаження розривом відповідної лінії. Контакти мікросхем з обох кінців лінії можуть бути з’єднані з метою відновлення. Лінія маркована «RESET-EN». Вимкнення автоматичного перезавантаження також можливо підключивши резистор 110 Ом між джерелом 5 В і даною лінією.
		</p>
		<h4>Струмовий захист роз’єму USB</h4>
		<p>
		В Arduino Mega2560 вбудовано запобіжник (який спрацьовує автоматично), що захищає порт USB комп’ютера від струмів короткого замикання і надструмів. Хоча практично всі комп’ютери мають подібний захист, тим не менш, цей запобіжник забезпечує додатковий бар’єр. Запобіжник автоматично перериває обмін даними при проходженні струму більше 500 мА через USB порт.
		</p>
		<h4>Фізичні характеристики та сумісність з платами розширення</h4>
		<p>
		Довжина і ширина друкованої плати Mega2560 складають 10.2 і 5.3 см відповідно. Роз’єм USB і силовий роз’єм виходять за межі даних розмірів. Три отвори в платі дозволяють закріпити її на поверхні. Відстань між цифровими виводами 7 і 8 дорівнює 0,4 см, хоча між іншими виводами воно становить 0,25 см.
		</p>
		<p>
		Arduino Mega2560 сумісна з усіма платами розширення, розробленими для платформ Uno, Duemilanove або Diecimila. Розміщення виводів 0-13(а також AREF та GND), аналогових входів 0-5, силового роз’єму, ICSP роз’єм, порту послідовної передачі UART (виводи 0 та 1) та зовнішнього переривання 0 та 1 (виводи 2 та 3) на Mega відповідають розміщенню на вищезазначених платформах. Зв’язок SPI може виконуватись через роз’єм ICSP, як на платформі Duemilanove/Diecimila, так і на Mega2560. Однак розміщення виводів (20 та 21), зв’язку I2C на платформі Mega, не відповідає розміщенню тих самих виводів (аналогові виходи 4 та 5) на Duemilanove / Diecimila.
		</p>
	</div>",

"ide" =>"Cереда розробки Arduino",
"ide_info" =>"Загальні відомості",
"ide_info_desc" =>"
	<p>
		 Середа разработки Arduino складається з вбудованого текстового редактора програмного коду, області повідомлень, вікна вивода тексту (консолі), панелі инструментів з кнопками часто використовуваних команд та декількох меню. Для завантаження програм і зв'язку середа розробки підключається до аппаратної частини Arduino.
	</p>
	<p>
		 Програма, написана в середовищі Arduino, називається скетч. Скетч пишеться в текстовому редакторі, мающім инструменти вирізки/вставлення, пошуку/заміни тексту. В час збереження та экспорту проекта в області повідомлень з'являються інформаційні повідомленняю Вікно вивода тексту (консоль) показує повідомлення Arduino.
	</p>
	<ul>
		<li>компіляція коду Verify/Compile (перевірка програмного коду на помилки, компіляція);</li>
		<li>зупинення моніторинга Stop (зупинення моніторинга послідовної шини (Serial monitor));</li>
		<li>створення нового скетча New;</li>
		<li>відкрити файл скетча Open (відкриття меню доступа до усіх скетчів в блокноті);</li>
		<li>збереження скетча Save;</li>
		<li>загрузка скетча в контролер Upload to I/O Board (компілює программий код та завантажує його до пристрою Arduino.);</li>
		<li>открытие мониторинга последовательной шины (Serial monitor).</li>
	</ul>",
"ide_menu" =>"
	<p style=> 'font-weight: bold;'>
		 Додадкові команди сгруповані в п'ять меню: File, Edit, Sketch, Tools, Help.
	</p>
	<h4>Підменю Edit:</h4>
	<ul>
		<li>Copy for Discourse (копіює до буферу код скетча для публікації на форумі);</li>
		<li>Copy as HTML (копіює до буферу код скетча як HTML код, для розміження на веб-сторінках);</li>
	</ul>
	<h4>Підменю Sketch:</h4>
	<ul>
		<li>Verify/Compile (перевірка на помилки);</li>
		<li>Import Library (додає бібліотеку до скетчу);</li>
		<li>Show Sketch Folder (відкриває директорію, де знаходиться скетч);</li>
		<li>Add File... (додає файл в скетч);</li>
	</ul>
	<h4>Підменю Tools:</h4>
	<ul>
		<li>Auto Format (опція оптимізує код);</li>
		<li>Board (вибір платформи);</li>
		<li>Serial Port (вибір порту);</li>
	</ul>",
"ide_extra" =>"Додаткова інформація",
"ide_extra_desc" =>"
	<h3>Загрузка скетча в Arduino</h3>
	<p>
		 До завантаження скетча треба завдати параметри в меню Tools > Board та Tools > Serial Port. Платформы описываются далее по тексту. В ОС Mac последовательный порт может обозначаться как dev/tty.usbserial-1B1 (для платы USB) или /dev/tty.USA19QW1b1P1.1 (для платы последовательной шины, подключенной через адаптер Keyspan USB-to-Serial). В ОС Windows порты могут обозначаться как COM1 или COM2 (для платы последовательной шины) или COM4, COM5, COM7 и выше (для платы USB). Определение порта USB производится в поле Последовательной шины USB Диспетчера устройств Windows. В ОС Linux порты могут обозначаться как /dev/ttyUSB0, /dev/ttyUSB1.
	</p>
	<p>
		 После выбора порта и платформы необходимо нажать кнопку загрузки на панели инструментов или выбрать пункт меню File > Upload to I/O Board. Современные платформы Arduino перезагружаются автоматически перед загрузкой. На старых платформах необходимо нажать кнопку перезагрузки. На большинстве плат во время процесса будут мигать светодиоды RX и TX. Среда разработки Arduino выведет сообщение об окончании загрузки или об ошибках.
	</p>
	<p>
		 При загрузке скетча используется Загрузчик (Bootloader) Arduino, небольшая программа, загружаемая в микроконтроллер на плате. Она позволяет загружать программный код без использования дополнительных аппаратных средств. Загрузчик (Bootloader) активен в течении нескольких секунд при перезагрузке платформы и при загрузке любого из скетчей в микроконтроллер. Работа Загрузчика (Bootloader) распознается по миганию светодиода (13 пин) (напр.: при перезагрузке платы).
	</p>
	<h3>Платформы</h3>
	<p>
		 Выбор платформы влияет на: параметры (напр.: скорость ЦП и скорость передачи данных), используемые при компиляции и загрузке скетчей и на настройки записи загрузчика (Bootloader) микроконтреллера. Некоторые характеристики платформ различаются только по последнему параметру (загрузка Bootloader), таким образом, даже при удачной загрузке с соответствующим выбором может потребоваться проверка различия перед записью загрузчика (Bootloader).
	</p>",

"browse" =>"Відкрити...",
"upload" =>"Завантажити",
"start" =>"Розпочати",
"send" =>"Відправити",
"registration" =>"Реєстрація",
//LED
'led_desc_1' =>"В даному експерименті здійснюється управління набором світлодіодів. Управління здійснюється через цифрові виводи плати Arduino. Діоди підключені через струмообмежуючі резистори і мають загальне заземлення.",
'led_desc_2' =>"Програмний код складається з функцій setup і loop. Перша виконується один раз при включенні плати. В даному випадку в ній виконується встановлення виводів з 2 по 5 в режим виходу з допомогою виклику pinMode, параметрами якого є номер виводу і його режим. Друга функція loop виконується в нескінченному циклі весь інший час роботи плати. В даному випадку проводиться зміна яскравості діодів, які підключені до виводів 2-5. Для зміни яскравості викликається функція analogWrite, яка подає на вивід, зазначений в своєму першому параметрі, напруга, вказана у другому. Напруга змінюється в діапазоні 0-5В, але функція приймає не значення вольтажу безпосередньо, а число від 0 до 255, що відповідає напрузі на проміжку 0-5В. Зміна напруги виконується за допомогою широтно-імпульсної модуляції. Так само в програмі використовується виклик delay, який призупиняє роботу плати на вказану кількість часу (мс). Це потрібно для того, щоб робота виконувалася досить повільно, щоб можна було помітити зміну яскравості.",
'led_desc_3' =>"У цьому прикладі в циклі проводиться послідовне включення і виключення кожного діода з затримкою в 700мс.",
'led_desc_4' =>"Мерехтіння світлодіодів",
'led_desc_5' =>"У цьому прикладі у функції loop виконується почергове включення всіх діодів в першому циклі і їх послідовно виключенні в другому. Ці цикли чергуються.",
'led_desc_6' =>"Плавна зміна яскравості",
'led_desc_7' =>"В цьому прикладі, по черзі для кожного діода виробляється плавну зміну яскравості від нуля до максимуму і назад. Зміна яскравості проводиться у вкладених циклах.",
'led_desc_8' =>"Почергове включення",
'led_desc_9' =>"Симуляція дефектного світлодіода",
'led_desc_10' =>"В даному експерименті, програмно перевіряється справність світлодіода за допомогою аналогового порту",
//Distance
'distance_title' =>"Ультразвуковий датчик відстані",
'distance_desc' =>"В даному експерименті проводиться читання показань ультразвукового датчика відстані. Датчик має три виводи: живлення, землі і сигнальний. Сигнальний вивід підключений на цифровий вивід плати, дані надходять в послідовному коді.",
'distance_desc_1' =>"В даному прикладі передача показників сенсора відстані на комп’ютер виконується через послідовний інтерфейс. Для роботи з ним використовується клас Serial, через який і відбувається вся взаємодія з інтерфейсом. Програмний код складається з функцій setup і loop. Перша виконується один раз при включенні плати. В даному випадку в ній виконується ініціалізація послідовного інтерфейсу за допомогою виклику begin, параметром якого служить частота передачі даних, також проводиться установка режимів для виводів датчика функцією pinMode, параметрами якої є номер виводу і режим. Також перед описом функції setup оголошуються змінні, що зберігають номера виводів, до яких буде підключений датчик відстані. Друга функція – loop, виконується в нескінченному циклі весь інший час роботи плати. Робота з датчиком відстані проводиться в два етапи, які постійно змінюють один одного: запит на вимір і читання показників. Так як датчик є ультразвуковим, показники, які повертаються їм, являють собою час, за яке ультразвуковий сигнал пройшов до об’єкта і назад. Зважаючи на це, після читання показань слід перетворити значення, щоб обчислити відстань. Для запиту на датчик протягом більше 10 мкс подається логічна одиниця. Перед і після неї передається логічний нуль. Це потрібно для того, щоб упевнитися, що датчик правильно зчитав команду. Дані операції проводяться за допомогою викликів digitalWrite, параметрами якого є номер виходу і значення (LOW або HIGH).",
'distance_desc_1-1' =>"Між викликами проводиться затримка за допомогою функції delayMicroseconds. Для читання показників датчика зчитується тривалість вхідного сигналу. Це робиться за допомогою виклику функції pulseIn, параметрами якої є номер входу і сигнал, тривалість якого слід дізнатися (логічний 0 або 1). Ця функція повертає тривалість сигналу в мкс. Отримане значення заноситься в змінну duration. Після отримання цього значення, за допомогою функцій microsecondsToCentimeters і microsecondsToInches проводиться арифметичне перетворення значення часу в відстань в см і дюймах відповідно. По завершенню цих операцій здійснюється пересилка отриманої інформації через серійний інтерфейс (Serial) за допомогою виклику print.",
'distance_desc_2' =>"Вимірювання дистанції",
'distance_desc_3' => "Датчик відстані з сервоприводом",
'distance_desc_4' =>"В даному експерименті датчик відстані повертається за допомогою сервоприводу. Це дозволяє вимірювати дистанцію до різних об’єктів. На стенді на різній відстані від датчика розташовані перегородки. Користувачеві пропонується проводити повороти двигуна з подальшим зняттям показань датчика відстані. Положення двигуна задається викликом write, параметром якого є кут повороту. В даному випадку значення кутів зберігаються в масиві і по черзі задаються двигуну. Команда на вимірювання відстані подається датчику за допомогою імпульсу тривалістю 10мкс. Для цього послідовно проводиться запис значень (0 і 1) за допомогою виклику DigitalWrite в відповідний вивід. Після вимірювання відстані проводиться читання показань датчика (час проходу ультразвукового сигналу) за допомогою виклику pulseIn. Відображення даних користувачеві проводиться через послідовний інтерфейс за допомогою функції print.",

// Servo
'servo_desc_1' =>"В даному експерименті здійснюється управління сервоприводу. Управління виконується послідовним кодом через цифровий вивід. Сервопривод має три виводи: живлення, земля і сигнальний.",
'servo_desc_2' =>"В першу чергу слід відзначити, що в програмі підключена бібліотека Servo.h, що відповідає за управління сервоприводом. Вона надає можливість користуватися класом Servo, через який і здійснюється управління. Можна побачити, як на початку програми створюється об’єкт цього класу. Програмний код складається з функцій setup і loop. Перша виконується один раз при включенні плати. У ній виконується установка керуючого виходу для сервоприводу на вивід 9 за допомогою виклику методу attach об’єкта myservo. Друга функція loop виконується в нескінченному циклі весь інший час роботи плати. У даній функції викликаються команди управління сервоприводом, що задають його позицію в градусах (write). Слід зазначити, що діапазон роботи сервоприводів може відрізнятися, в залежності від привода і не тільки дорівнює 0-180. Команда delay використовується для припинення роботи плати на вказану кількість мілісекунд. Це необхідно тому що швидкість роботи сервопривода механічно обмежена, і він не здатний змінювати позицію настільки швидко, на скільки контролер здатний робити запити.",
'servo_example_1' =>"Поворот на дві позиції",
'servo_desc_3' =>"В цьому прикладі сервоприводу по черзі задаються 2 позиції. Між цим проводиться затримка в 2с, щоб двигун встиг зробити поворот до отримання наступної команди.",
'servo_example_2' =>"Плавне обертання",
'servo_desc_4' =>"В цьому прикладі проводиться плавний поворот привода. Для цього в циклі кожні 15мс викликається функція зміни позиції привода з різницею в 1 градус.",
// Display
'display_desc_1' =>"В даному експерименті здійснюється управління ЖК дисплеєм (LCD) і ЖК дисплеєм з активною матрицею (LCD TFT). Управління зображенням дисплея проводиться через цифрові виводи по протоколу послідовної передачі даних I2C.",
'display_desc_2' =>"В першу чергу слід відзначити, що в даній програмі підключені бібліотеки LiquidCrystal_I2C.h (що відповідає за управління ЖК-дисплеєм) і Wire.h (реалізує I2C протокол). Бібліотеки надають можливість користуватися класом LiquidCrystal_I2C, через який і здійснюється управління. Можна побачити, як на початку програми створюється об’єкт цього класу. В даному випадку параметри відповідають вбудованому в екран контролера і змінювати їх не рекомендується. Програмний код складається з функцій setup і loop. Перша виконується один раз при включенні плати. В даному випадку в ній виробляється установка параметрів роботи ЖК-дисплея за допомогою виклику begin c параметрами, які дають зрозуміти кількість стовпців і рядків символів. Для включення/виключення вбудованої підсвічування дисплея використовуються функції backlight/noBacklight. Друга функція loop виконується в нескінченному циклі весь інший час роботи плати. В даному випадку в ній виконується установка курсору в початок другого рядка (нумерація проводиться з нуля) за допомогою виклику setCursor і друк часу роботи плати в секундах. Функція print викликається для виведення на екран зазначеного набору символів. Виклик clear дозволяє очистити вміст екрану, а функція delay призупиняє роботу плати на вказаний в мілісекундах час.",
'display_example_1' =>"Hello, world!",
'display_desc_3' =>"В даному приклад в першу строку екрану друкується повідомлення «Hello, world!», а після 1 секунди в другу строку виводиться «I am display». Пілся ще 1 секунди екран стає пустим. Дії повторюються циклічно.",
'display_example_2' =>"Рухомий рядок",
'display_desc_4' =>"В даному прикладі реалізован рядок, що рухається. У кожній ітерації циклу проводиться зсув початкової позиції курсора, з якої на наступний ітерації буде проводитися відображення тексту.",
'infoFirst_desc' =>"На Ваш вибір надаються такі експерименти:",
'infoTitle' =>"Керівництво користувача",
'infoFirst' =>"1. Оберіть експеримент",
'infoSecond' =>"2. Ознайомтесь з ним",
'infoSecond_desc' =>"На сторінці з експериментом доступні:",
'infoSchema' =>"Схема експерименту",
'infoDescription' =>"Опис сценаріїв експерименту",
'infoSamples' =>"Приклади програмних кодів експерименту",
'infoThird' =>"3. Виконайте експеримент",
'infoThird_desc' =>"На сторінці с експериментом ви можете скористатись прикладом коду або написати свій.",
'infoFourth' =>"4. Слідкуйте за результатом",
'infoFourth_desc' =>"В час виконання експерименту ви можете слідкувати за результатами сервера.",
'example' =>"Приклад коду",
'name' =>"ім'я",
'sname' =>"прізвище",
'stud' =>"студент",
'personal' =>"особисте використання",
'register' =>"Зареєструватись",
'emailMessage' =>"Дякую за реєстрації в нашій системі для подтвердження реєстрації перейдіть за цим посиланням: ",
"startTime" =>"Почав",
"endTime" =>"Закінче",
"theme" =>"Тема",
"documentation" =>"документація",
"apiDesc" =>"RELDES API обеспечивает доступ к ресурсам (сущностям данных) с помощью URI. Для использвания API RELDES, приложение отправляет HTTP запрос и анализирует ответ. Формат ответа JSON. API предоставляет стандартные методы HTTP GET, PUT, POST и DELETE. Вы можете использовать любой язык разработки для доступа к API с использованием запроса HTTP.",
"apimethods" =>"Методы API:",
'stat' =>"Статистика",
'expStatuses' =>"Состояние экспериментов",
'mailer' =>"Оповещания",
'usage' =>"Использование экспериментов",
'queue' =>"Очередь",
'apiDesc1' =>' Для использвания нашего API вам необходимо пройти регистрацию, пройдя которую вы получите ваш API KEY, вам
            необходимо будет его включить в параметры запроса как: key=YourAPIkey.
            Также наше API использует HTTP Basic Auth, поэтому при отправке запроса вы должны установить в заголовке запроса
            строку: "Authorization: Basic "+ преобразовать строку "user:password" в base64.',
'apiDesc2' =>'Статус эксперимента',
'apiDesc3' =>'Занять эксперимент',
'apiDesc4' =>'Возвращает текущее состояние эксперимента.',
'apiDesc5' =>'Пример запроса',
'apiDesc6' =>'где 1ый параметр может варироваться от 1 до 4, и означать номер эксперимента',
'apiDesc7' => 'Пример ответа',
'apiDesc8' => 'user_id - id пользователя в системе который сейчас работает над экспериментом.',
'apiDesc9' => 'Где',
'apiDesc10' => 'status  - текущий статус эксперимента 1 - занят, 0 - свободен',
'apiDesc11' => 'end     - время окончания эксперимента для пользователя с текущим user_id',
'apiDesc12' => 'Позволяет занять эксперимент',
'apiDesc13' =>'message - сообщение в котором может быть несколько ответов:',
'apiDesc14' =>'этот пользователь уже стоит в очереди на данный эксперимент,
        "success" - пользователь успешно зарегестрирован в очереди',
'apiDesc15' =>'status  - будет установлен в false если пользователь будет в очереди, true если он эксперимент был свободен и он его сразу занял',
'apiDesc16' =>'Время эксперимента',
'apiDesc17' =>'Возвращает перечень данных о старте, окончании , ожидании эксперимента',
'apiDesc18' =>' время ожидания в очереди, если отрицательное значит текущий пользователь уже занял эксперимент столько секунд назад',
'apiDesc19' =>'1 если пользователь выполняет эксперимент, 0 если стоит в очереди',
'apiDesc20' =>'время старта эксперимента',
'apiDesc21' =>'время окончания эксперимента',
'apiDesc22' =>'Очередь эксперимента',
'apiDesc23' =>'Возвращает перечень всех пользователей в очереди на данном эксперименте',
'apiDesc24' =>'Очереди экспериментов',
'apiDesc25' =>'Возвращает перечень всех очередей на всех экспериментах',
'apiDesc26' =>'id эксперимента',
'apiDesc27' =>"пользователя который выполняет эксперимент",
"expUploadCode" =>"Загрузить код",
'apiDesc28' =>'Загружает код на плату.',
'apiDesc29' =>'Параметры:',
'apiDesc30' =>'код для загрузки',
'wireless' =>'Кібербезпека',
'clean' =>'Пустий код',
'copy' =>'Копiювати',

/**VIRTUAL MODEL */
'virtual_model' =>'Віртуальна модель',
'vritual_model_error' =>'Виртуальная модель на данный момент не поддерживается на мобильных устройствах',



/** IOT */
'description' =>"Опис",
'run' =>"Виконання эксперименту",
'tpc' =>"Типовий програмний код",
'rp' =>"Реальний проект",
'dote' =>'Опис експерименту',
'cote' =>'Компоненти експерименту',

'solar_1' =>"Експеримент дозволяє вивчити принципи отримання та накопичення сонячної енергії. Також експеримент демонструє типову схему організації процесу накопичення енергії в акумуляторах.",
'solar_2' =>"В ході експерименту можна простежити зміну напруги, що виробляється сонячною панеллю при зміні інтенсивності освітлення. Для проведення експерименту включіть освітлення і проаналізуйте зміни на графіку.",
'solar_3' =>'Arduino Nano V3 (5V)',
'solar_4' =>'Сонячна панель (6В, 250мА)',
'solar_5' =>'Резистивний дільник  (1/2)',
'solar_6' =>'Контролер заряду (TP4056)',
'solar_7' =>'Акумулятор (3.7V, 1100мА)',
'solar_8' =>'Ввiмкнути/вимкнути свiтло',
'solar_9' =>'Напруга сонячної станції(V)',
'solar_10' =>'Сонячна панель',
'solar_11' =>'Контролер заряду',
'solar_12' =>'Інвертор',
'solar_13' =>"Акумулятори",

//illumination
'illum_1' =>'Експеримент дозволяє вивчити основи роботи драйвера навантажень і принципу створення різнокольорових (RGB) світлодіодних систем освітлення, а також управління RGB світлодіодною стрічкою.',
'illum_2' =>'Arduino NANO має функціональну можливість на окремих виводах генерувати ШІМ (широтно-імпульсна модуляція) сигнал, який передається на входи драйвера навантажень L298N. Модуль L298N виступає в ролі RGB контролера і дає можливість управляти чотирма каналами навантаження постійного струму в залежності від вхідного ШІМ сигналу. Рівень вихідного постійного струму на каналах RGB стрічки пропорційний вхідному каналу',
'illum_3' =>'Драйвер навантажень L298 (5-35V, 2A)',
'illum_4' =>'RGB LED лента',
'illum_5' =>'Блок живлення постійного струму 5V, 1А and 12V, 4А',
'illum_6' =>'Вибір кольору',
'illum_7' =>'Вибір настрою',
'illum_8' =>'Зміна кольору',
'illum_9' =>'Виберіть потрібний колір світла на стрічці та натисніть «вибрати».',
'illum_10' =>'RGB колір',
'illum_11' =>'Освітлення можна встановити не тільки за кольором, але і за настроєм.
Виберіть потрібний настрій і оцініть колір освітлення.',
'illum_12' =>'Виберіть настрій',
'illum_13' =>'Захоплення',
'illum_14' =>'Розслабтесь',
'illum_15' =>"Смуток",
'illum_16' =>"Увімкніть вимикач і оцініть результат при різних швидкостях.",
'illum_17' =>"Виконати сценарій з випадковими кольорами",
'illum_18' =>"RGB контролер",
'illum_19' =>"Схема з'єднання компонентів",

//climate
'climate_1' =>'Цей експеримент дозволяє вивчити метод кліматичного контролю на основі даних датчиків температури та вологості. Також реалізована можливість контролю якості повітря, використовуючи датчик визначення хімічних домішок у повітрі.',
'climate_2' =>'Датчик DHT11 (цифровий датчик температури (0-50 ° C) і вологістi (20-90%))',
'climate_3' =>'Датчик якості повітря MQ135 (Він призначений для визначення вмісту та кількості шкідливих та небезпечних газів у повітрі, таких як: NH3, NOx, алкоголь, бензин, дим, CO2 тощо. Він має цифровий (компаратор) та аналоговий вихід)',
'climate_4' =>'Кліматичні показники',
'climate_5' =>'Клімат-контроль',
'climate_6' =>'Температура на датчику',
'climate_7' =>'Вологість повітря на датчику',
'climate_8' =>'Якість повітря',
'climate_9' =>'Вологість ґрунту',
'climate_10' =>'Датчик вологості та температури Xiaomi',
'climate_11' =>'Датчик температури та вологості повітря (EVR_ST814)',
'climate_12' =>'ALQ-CO2 - Датчик якості повітря та вуглекислого газу',
'climate_13' =>'Датчик вологості / температури - EVR_ST814',

//acesss

'access_1' =>'Експеримент дозволяє вивчити принципи створення систем контролю доступу до різних приміщень за допомогою комбінованого блокування.',
'access_2' =>'Ідентифікатором доступу є RFID-карта або брелок і зчитувач RFID RC522.
RFID-зчитувач RC522 читає радіотеги, які знаходяться в межах зчитувача, постійно.',
'access_3' =>'RFID зчитувач RC522',
'access_4' =>'Servo SG90',
'access_5' =>'Модуль RFID проводить опитування з частотою 13,56 МГц і взаємодіє з контролером Arduino NANO v3 за допомогою інтерфейсу SPI.
Коли одна з клавіш (картка або брелок) переміщується до зчитувача, ключ зчитується та порівнюється з базою даних користувачів з авторизованим доступом у контролері. Користувачам, які не мають дозволу, відмовляють. Як привід використовується сервопривод SG90.',
'access_6' =>'Вхідні двері',
'access_7' =>'Комплект електричних замків',
'access_8' =>'RFID ключі',
'access_9' =>'Електричний замок',
'access_10' =>'Електричний привід блокування',

//safety
'safety_1' =>'Arduino NANO має можливість генерувати сигнал PWM (Pulse Wide Modulation) на деяких штирях, який передається на входи драйвера навантаження L298N.
Модуль L298N працює як контролер RGB і дає можливість керувати чотирма каналами навантаження постійного струму, в залежності від вхідного сигналу ШІМ. Рівень вихідного постійного струму на каналах стрічки RGB пропорційний вхідному каналу. Багатоколірна (RGB) світлодіодна стрічка (залежно від типу стрічки) має 4 входи (ЧЕРВЕНИЙ, ЗЕЛЕНИЙ, СВІТИЙ, + 12 В). Залежно від рівня постійного струму яскравість необхідних кольорів встановлюється на світлодіодах.
* Драйвер навантаження L298N має можливість керувати навантаженнями струмом 2А. Зверніть увагу на характеристики світлодіодної стрічки.',
'safety_2' =>'Сигналізація',
'safety_3' =>'Виберіть режим роботи сигналізації',
'safety_4' =>'статус',
'safety_5' =>'Вікно',
'safety_6' =>'Електричний привід для вікон',
'safety_7' =>'PIR датчики',

//zone
'zone_1' =>"Експеримент дозволяє вивчити принципи створення систем безпеки на основі лазерів. Це дає можливість реалізації невидимих контрольованих бар'єрів для конкретних зон.",
'zone_2' =>'Експеримент був створений для вивчення функціонування та побудови систем управління периметром на основі джерела лазерного передавача та приймача. Ці системи дозволяють керувати певною областю за допомогою дуже тонкого лазера з великою робочою дистанцією. У таких системах часто використовують лазерні відбивачі.',
'zone_3' =>'Модуль лазера',
'zone_4' =>'Датчик світла',
'zone_5' =>'Увімкніть керування периметром та імітуйте перетин периметра, відкривши гаражні двері. Перегляньте результат увімкнення світлового сигналу у вікні експерименту.',
'zone_6' =>'Увімкнення / вимкнення керування периметром',
'zone_7' =>'Перетинання периметра',
'zone_8' =>'Infrared perimeter example',

//presence
'presence_1' =>'Експеримент дозволяє вивчити принципи роботи систем моніторингу присутності та систем безпеки шляхом зміни режиму роботи підсистеми. Можливість контролю руху в декількох областях реалізована.',
'presence_2' =>'PIR-датчик (пасивний інфрачервоний датчик, часто використовується в системах сигналізації)',
'presence_3' =>'Міжкімнатні двері',

//ventilation
'vent_1' =>'Експеримент демонструє принципи побудови системи вентиляції з регулюванням швидкості потоку повітря та нагріванням повітря для обігріву приміщень.',
'vent_2' =>'Arduino Nano генерує широкоімпульсний сигнал для драйвера навантаження L298, тим самим контролюючи швидкість вентилятора.
Також Arduino Nano управляє елементом Peltier за допомогою модуля реле для нагріву повітря. Датчик DHT22 контролює температуру і вологість в приміщенні.',
'vent_3' =>'L298 Драйвер управління навантаженням',
'vent_4' =>'Реле 5В',
'vent_5' =>'Елемент Пельтьє',
'vent_6' =>'Датчик температури і вологості DHT22',
'vent_7' =>'Для проведення експерименту перетягніть повзунок у потрібне положення, тим самим регулюючи швидкість вентилятора у вентиляційній системі.
Увімкніть нагрівання повітря та проаналізуйте результати на графіку.
Контролюйте швидкість вентилятора та аналізуйте результати на графіку.',
'vent_8' =>'Увімкніть \ вимкніть опалення',
'vent_9' =>'Рекуператор',
'vent_10' =>'Блок рекуператору',
'vent_11' =>'Внутрішня конструкція рекуператора',
'vent_12' =>'Повітряний опалювальний прилад',

//light
'light_1' =>'Експеримент дає можливість вивчити основи роботи диммера на прикладі управління білою світлодіодною смужкою. Диммер дозволяє контролювати електричну потужність і тим самим контролювати рівень освітленості. Експеримент також дає можливість відтворити алгоритм автоматичного управління при необхідних умовах.',
'light_2' =>'Arduino Nano отримує числове значення для необхідного рівня освітленості і генерує сигнал ШІМ (імпульсна широка модуляція) для драйвера навантаження. Водій навантаження керує напругою на світлодіодах. Таким чином, рівень освітленості контролюється. Водій навантаження виконує функцію затемнення. Диммер, залежно від типу, може керувати альтернативною та прямою напругою.',
'light_3' =>'LED стрічка',
'light_4' =>'Контроль рівня світла',
'light_5' =>'Встановлення освітленості',
'light_6' =>'Перетягніть повзунок, щоб змінити рівень освітлення (від 0 до 100%) та проаналізуйте дані з датчика світла.',
'light_7' =>'Встановіть час доби і оцініть рівень освітленості.',
'light_8' =>'Діммер напруги змінного струму',
'light_9' =>'Діммер напруги постійного струму (промисловий)',
'light_10' =>'Диммерований диммер для світлодіодів',
'light_11' =>'LED стрічка (Біла)',



//cyber
'cyber_1' =>'Експеримент дозволяє вивчити принцип роботи бездротових wi-fi датчиків та дослідити їх безпеку.',
'cyber_2' =>"Експеримент демонструє можливість використання бездротових датчиків Wi-Fi для моніторингу індикаторів системи Smart House, а також результати порушення з'єднання Wi-Fi через деаутентифікацію.
Показано можливості застосування мобільних та хмарних технологій для ефективного зберігання, візуалізації даних та моніторингу стану системи.",
'cyber_3' =>'Датчик DHT11 (цифровий датчик температури (0-50 ° C) і вологість (20-90%))',
'cyber_4' =>'Датчик якості повітря MQ135 (Він призначений для визначення вмісту та кількості шкідливих та небезпечних газів у повітрі, таких як: NH3, NOx, алкоголь, бензин, дим, СО2 тощо. Він має цифровий (компаратор) та аналоговий вихід )',
'cyber_5' =>'Деавторизація - це атака, яка надсилає пакети для відключення одного або декількох клієнтів, які зараз підключені до певної точки доступу. У цьому експерименті використовується примусове відключення клієнта (захоплення рукостискань WPA / WPA2).
Натисніть кнопку ATTACK, спостерігайте за збоєм в отриманні даних від датчика.',
'cyber_6' =>'Атака',
'cyber_7' =>"Стан з'єднання",
'cyber_8' =>'Деактивація',
'cyber_9' =>'Мобільні технології',
/** end IOT */
'rpi_sd' =>"Raspberry Pi - одноплатний комп'ютер розміром з банківську карту, спочатку розроблений як бюджетна система для навчання інформатиці, що згодом одержав набагато більш широке застосування і популярність. Перші версії були створені в 2011 році. Побудований на основі процесора архітектури ARM.
Raspberry Pi працює в основному на операційних системах, заснованих на Linux ядрі, таких як:",
'pi_ul_li1' =>'Raspbian (модифікація Debian)',
'pi_ul_li2' =>'Pidora (модифікація Fedora)',
'pi_ul_li3' =>'Arch Linux ARM',
'pi_ul_li4' =>'Kali Linux',

'pi_install_desc' =>'Існує два способи встановлення ОС Raspbian на Raspberry Pi:',
'pi_install_desc_li1' =>'завантаження пакета NOOBS з офіційного сайту на карту пам’яті MicroSD та подальше встановлення;',
'pi_install_desc_li2' =>'монтування файлу-образу ОС Raspbian на карту пам’яті MicroSD. В цьому випадку можна буде приступати до роботи одразу після включення Raspberry Pi.',
'pi_install_v1' =>'Приклад встановлення ОС Raspbian за допомогою пакета NOOBS',
'pi_install_v1_desc_1' =>'Необхідно завантажити пакет з офіційного сайту https://www.raspberrypi.org/downloads/noobs/ . Слід обрати NOOBS «Offline and network install» для встановлення без мережі Інтернет чи NOOBS LITE «Network install only» для встановлення з мережею Інтернет.',
'pi_install_v1_desc_2' =>'Перед тим як записувати файли NOOBS на карту пам’яті microSD, її слід відформатувати у файлову систему FAT32.
Далі слід розпакувати архів NOOBS на карту пам’яті microSD.
Наступний крок – підключення периферії до Raspberry Pi: USB-клавіатури, USB-миші, монітору (через HDMI), а також необхідно встановити карту пам’яті microSD у відповідний слот. В останню чергу підключається живлення MicroUSB.
В окні що відобразиться слід обрати ОС Raspbian (перша опція). Друга опція пропонує розбивку розділів карти пам’яті вручну, третя опція – завантаження безпосередньо у пакет Scratch – програму для створення комп’ютерної графіки та анимацій.
Необхідно натиснути «Install» та підтвердити запис даних на карту пам’яті MicroSD. Слід дочекатися завершення процесу встановлення та перезавантаження. У вікні Configuration Tool (налаштування можна змінити пізніше) слід обрати опцію «Enable boot to Desktop» та підтвердити вибір, що дозволить зробити LXDE інтерфейсом за замовчуванням при завантаженні. Далі слід натиснути «Done» та погодитися на перезавантаження. Після чого все буде готово до роботи.',
'pi_install_v2' =>'Приклад встановлення ОС Raspbian за допомогою монтування файлу–образу',
'pi_install_v2_desc_1' =>'Спочатку необхідно завантажити ОС з офіційного сайту: https://www.raspberrypi.org/downloads/raspbian/. Рекомендовано обрати «Raspbian Stretch With Desktop».',
'pi_install_v2_desc_2' =>'Також необхідно встановити на комп’ютер утиліту Win32DiskImager (https://sourceforge.net/projects/win32diskimager/) та за її допомогою записати файл-образ ОС Raspbian на карту пам’яті microSD:',
'pi_install_v2_desc2_li1' =>'необхідно розпакувати архів з файлом-образом на комп’ютері',
'pi_install_v2_desc2_li2' =>'слід відформатувати карту пам’яті стандартним засобом ОС Windows',
'pi_install_v2_desc2_li3' =>'далі необхідно у програмі Win32DiskImager обрати файл-образ ОС Raspbian (наприклад: «2017-09-07-raspbian-stretch.img»)',
'pi_install_v2_desc2_li4' =>'у розділі «Device» слід обрати ім’я карти пам’яті microSD. Слід бути уважним, якщо помилитись можна нанести шкоду жорсткому диску',
'pi_install_v2_desc2_li5' =>'нарешті слід обрати «Write» та дочекатися завершення процесу запису. Приблизний час запису становить 5–10 хвилин',
'pi_install_v2_desc3' =>'Далі необхідно здійснити підключення периферії до Raspberry Pi: USB-клавіатури, USB-миші, монітору (через HDMI), а також необхідно встановити карту пам’яті microSD у відповідний слот. В останню чергу підключається живлення MicroUSB.',
'pi_install_v2_desc3_li1' =>'Відбудеться завантаження ОС Raspbian та все буде готово до роботи.',
'pi_install_v2_desc3_li2' =>'Якщо використовується Unix-подібні ОС:',
'pi_install_v2_desc3_li3' =>'cлід від форматувати карту пам’яті microSD у FAT 32/ext2',
'pi_install_v2_desc3_li4' =>'виконати команду: sudo dd bs=4m if=/home/user/raspbian.img of=/dev/disk1;',
'pi_install_v2_desc3_li5' =>'Далі необхідно здійснити підключення периферії до Raspberry Pi: USB-клавіатури, USB-миші, монітору (через HDMI), а також необхідно встановити карту пам’яті microSD у відповідний слот. В останню чергу підключається живлення MicroUSB.',
'pi_install_v2_desc3_li5' =>'Відбудеться завантаження ОС Raspbian та все буде готово до роботи.
Важливо запам’ятати, що запуск Raspberry Pi відбувається одразу після підключення MicroUSB, та що вимикати Raspberry Pi слід наступним чином:',
'pi_install_v2_desc3_li6' =>'завершити всі дії',
'pi_install_v2_desc3_li7' =>'натиснути на лого Raspberry Pі у верхньому лівому куті',
'pi_install_v2_desc3_li8' =>'обрати опцію «Shutdown» та у новому вікні підтвердити – «Shutdown»',
'pi_install_v2_desc3_li9' =>'Тільки після того як Raspberry Pі буде виключено, можна від’єднати шнур MicroUSB та змінювати склад периферії, підключеної до Raspberry Pі.',
'fr' =>'Перший запуск ОС Raspbian',
'fr_desc_1' =>'Якщо було ввімкнено завантаження у графічне середовище, введення паролю користувача не потрібне, але якщо пароль було змінено, може знадобитися його введення.
У випадку консольного режиму необхідно ввести логін та пароль («pi» та «raspberry», відповідно). Щоб запустити графічне середовище, необхідно виконати команду «startx».
У верхній частині екрану знаходиться панель задач, панель швидкого доступу та кнопка меню.
На панелі швидкого запуску знаходяться:',
'fr_desc_1_li1' =>'браузер',
'fr_desc_1_li2' =>'Провідник',
'fr_desc_1_li3' =>'утиліта Terminal',
'fr_desc_1_li4' =>'програми пакету Wolfram',
'fr_desc_2' =>'Натиснувши на кнопку меню (лого Raspberry Pi) можна переглянути програми встановлені в системі.
В меню містяться такі розділи:',
'fr_desc_3_li1' =>'Programming: містить програми та засоби для програмування (Python IDE, Geany, BlueJ, тощо)',
'fr_desc_3_li2' =>'Office: містить «офісні» програми (пакет OpenOffice)',
'fr_desc_3_li3' =>'Internet: містить програми та засоби для роботи в мережі Інтернет',
'fr_desc_3_li4' =>'Games: містить ігри (MineCraft)',
'fr_desc_3_li5' =>'Accessories: містить додаткові супутні програми (Archiver, калькулятор)',
'fr_desc_3_li6' =>'Sound & Video: містить відео- та аудіо–плеєри (VLC Player)',
'fr_desc_3_li7' =>'System Tools: містить системні програми (Midnight Commander)',
'fr_desc_3_li8' =>'Help: довідка',
'fr_desc_3_li9' =>'Preferences: налаштування системи',
'fr_desc_3_li10' =>'Run: виконати дію',
'fr_desc_3_li11' =>'Shutdown: перехід до вікна вимкнення плати',
'fr_desc_4' =>'В основному, для виконання більшості дій у Raspbian (як у будь–якій Unix-подібній ОС) використовується утиліта Terminal. Для її запуску слід натиснути відповідну піктограму.',
'fr_desc_5' =>'В процесі роботи може знадобитися змінити конфігурацію системи, змінити пароль користувача, увімкнути камеру, тощо. Все це можна зробити за допомогою команди sudo raspi-config',
'fr_desc_5_li' =>'Докладніше про пункти меню:',
'fr_desc_5_li1' =>'Change User Password –зміна пароля користувача',
'fr_desc_5_li2' =>'Hostname – ім’я комп’ютера в мережі',
'fr_desc_5_li3' =>'Boot options – налаштування завантаження системи',
'fr_desc_5_li4' =>'Localisation Options – вибір мови та регіональних налаштувань',
'fr_desc_5_li5' =>'Interfacing Options – налаштування інтерфейсів (камера, SSH, VNC, SPI, I2C, Serial, 1-Wire, GPIO)',
'fr_desc_5_li6' =>'Overclock – збільшення частоти процесору',
'fr_desc_5_li7' =>'Advanced Options – додаткові параметри',
'fr_desc_5_li8' =>'Update – оновлення програми raspi-config',
'fr_desc_5_li9' =>'About raspi-config – інформація про програму',
'fr_desc_6' =>'Завершивши налаштування, слід обрати Finish. ОС запросить дозвіл на перезавантаження. Слід погодитися та дочекатися закінчення перезавантаження.
При зміні налаштувань системи слід бути уважним, помилка може призвести до небажаних наслідків.',
'fr_desc_7' =>'Налаштування мережі Інтернет',
'fr_desc_8' =>'У випадку підключення до мережі, в якій налаштовано DHCP-сервер та автоматичний розподіл адрес (наприклад, домашня мережа), додатково нічого не потрібно робити.
Якщо DHCP відсутній, параметри мережі можна задати за допомогою консолі. Для цього необхідно запустити термінал, де слід відкрити файл налаштувань мережевих інтерфейсів за допомогою команди: sudo nano /etc/network/interfaces. До файлу треба додати наступне:
iface <інтерфейс> inet static
address <ip-адреса>
netmask <маска підмережі>
gateway <адреса шлюзу>
dns-nameservers <адреси DNS-серверів, розділенні пробілом>
auto <інтерфейс>,
де інтерфейс ‒ мережевий інтерфейс, підключений до Raspberry Pі (найчастіше це eth0);
ip-адреса ‒ адреса, яку необхідно присвоїти;
маска підмережі ‒ маска;
адреса шлюзу ‒ ip-адреса комп’ютеру, що служить в мережі шлюзом.
Далі необхідно вийти зі збереженням змін, для чого слід натиснути Ctrl+X, підтвердити збереження натисненням клавіші Y, а потім Enter для підтвердження перезапису файлу. Після змін файлу треба перезавантажити Raspberry Pi, виконавши команду sudo reboot.
Для перевірки налаштувань мережі слід виконати команду ifconfig',
'fr_desc_9' =>'Для роботи з проксі-сервером необхідно певні строки до файлів /etc/environment (загальносистемні налаштування проксі) та /etc/apt/apt.conf (налаштування пакетного менеджера apt-get).
До файлу /etc/environment слід дописати:
export http_proxy=«http://host:port», а до файлу /etc/apt/apt.conf: Acquire::http::proxy «http://host:port»; .
Після виконання даних дій, можна буде користуватися мережевими функціями, в тому числі і менеджером apt-get.',
'fr_desc_10' =>'Підключення Arduino із завантаженим скетчем',
'fr_desc_11' =>'Для того щоб підключити Arduino до Raspberry Pi потрібно',
'fr_desc_12' =>'Взяти скетч (програму) з лабораторної роботи №1 та підключеними датчиками до Arduino. Запустити скетч та залишити працювати.',
'fr_desc_13' =>'Витягнути Arduino USB-дріт з комп’ютера',
'fr_desc_14' =>'Вставити Arduino USB-дріт у працюючий Raspberry Pi',
'fr_desc_15' =>'Надати повний доступ до порту, що буде використовуватися Arduino. Для цього у терміналі написати:
chmod 777 /dev/ttyACM0',
'oh_title' =>'Інтеграція підсистем Розумного будинку на платформі OpenHAB',
'oh_text' =>"OpenHAB (Open Home Automation Bus) – створений на Java open source проект з реалізації технології «smart house», розповсюджується під ліцензією GPLv3, та для організації роботи web-інтерфейсу використовується Jetty.
Ця відкрита платформа здатна виконувати такі функції як вмикання та вимикання освітлення, керування розетками, тощо.
OpenHAB надає засоби для організації роботи різних систем, обладнання та інтерфейсів домашньої автоматизації. При цьому OpenHAB не залежить від протоколів і обладнання, надаючи окремий рівень абстракції, що дозволяє взаємодіяти з різними типами пристроїв і програмного забезпечення. Для визначення керуючої логіки використовуються скрипти, написані на спеціальній предметно-орієнтованій мові програмування, розробленій за допомогою Eclipse –Xtext.
Основним сервісом OpenHAB є шина подій. Модулі, які не вимагають відстеження стану, використовують цю шину для обміну інформацією про події з іншими модулями.
Існує два основних типи подій:
1. Команди, які ініціюють будь-яку дію чи зміна стану певного елемента або пристрою.
2. Оновлення статусу, які повідомляють про зміну стану певного елемента або пристрою.
Прив'язки протоколів, що забезпечують зв'язок з реальними пристроями, повинні спілкуватися між собою саме через шину подій. Це гарантує існування зв'язку між модулями.
В openHAB використовується дуже потужна мова виразів, за допомогою якої створюються визначення сценаріїв. Сценарій або скрипт – це блок коду, який визначається користувачем і може викликатися і використовуватися в різних місцях. Скрипти розміщуються в папці openhab/configurations/scripts. В робочому середовищі є демонстраційний файл demo.script.
Скрипти також можуть знаходитися всередині файлу правил, в папці openhab/configurations/rules: вони використовуються для визначення блоку виконання правила. Кожне правило складається з двох частин: в одній містяться перемикачі дій, в інших скриптах – для їх виконання.
Для ефективного використання скриптів OpenHAB надає доступ:",
'oh_li1' =>'до всіх елементів (отримати доступ можна звернувшись по імені);',
'oh_li2' =>'до всіх статусів та команд;',
'oh_li3' =>'до стандартних дій до виконання різних операцій',
'oh_text2' =>'Скрипт ідентифікується назвою (у файлу demo.script – ім\'я скрипта demo). Кожен скрипт завжди повертає значення, що є результатом останнього виразу, який міститься в ньому.
Скрипти можуть  викликатися:',
'oh_li4' =>'з правил;',
'oh_li5' =>'з XMPP-консолі;',
'oh_li6' =>'з записів в календарі Google.',
'oh_text3' =>'Встановлення та налаштування OpenHAB на Raspberry Pi',
'oh_text4' =>'Для встановлення OpenHAB на Raspberry Pi слід виконати послідовність дій та команд (за допомогою терміналу), що описані нижче.',
'oh_text4_li1' =>'Завантажити ключ: wget –qO - ‘https://bintray.com/user/downloadSubjectPublicKey?username=
openhab’ | sudo apt-key add –',
'oh_text4_li2' =>'Встановити репозиторій OpenHAB: echo “deb http://dl.bintray.com/openhab/apt-repo stable main” | sudo tee /etc/apt/sources.list.d/openhab.list',
'oh_text4_li3' =>'Оновити системні файли:
sudo apt-get update',
'oh_text4_li4' =>'Встановити OpenHAB:
sudo apt-get install openhab-runtime',
'oh_text4_li5' =>'Додати користувача до групи: sudo usermod –aG openhab pi',
'oh_text4_li6' =>'Запустити OpenHAB:
sudo systemctl enable openhab',
'oh_text4_li7' =>'Встановити доповнення для роботи з GPIO:
sudo apt-get install openhab-addon-io-gpio
sudo apt-get install openhab-addon-binding-gpio',
'oh_text4_li8' =>'Встановити доповнення для роботи з портами:
sudo apt-get install openhab-addons-binding-serial',
'oh_text4_li9' =>'Задати ім’я користувача та назву групи:
sudo nano /etc/default/openhab
sudo nano /usr/lib/systemd/system/openhab.service',
'oh_text4_li10' =>'Перевантажити systemd:
sudo systemctl daemon-reload',
'oh_text4_li11' =>'Додати порт який використовуватиметься з Arduino:
sudo nano /usr/share/openhab/bin/openhab.sh
В розділі «JAVA_ARGS_DEFAULT» додати в кінець',
'oh_text4_li12' =>'Перевантажити OpenHAB:
sudo service openhab restart',
'oh_text4_li13' =>'Написати код для отримання даних від Arduino:
sudo nano /etc/openhab/configurations/items/home.items',
'oh_text4_li14' =>'Створити інтерфейс для відображення даних:
sudo nano /etc/openhab/configurations/sitemaps/home.sitemap',
'oh_text4_li15' =>' Знайти процес Java та запам’ятати його номер:
top',
'oh_text4_li16' =>'Зупинити процес Java. Наприклад, номер Java процесу – 3234, тоді:
kill 3234',
'oh_text4_li17' =>'Перейменувати файл openhab_default.cfg у openhab.cfg в каталозі /etc/openhab/configurations/',
'oh_text4_li18' =>'Створити правило OpenHAB для керування датчиками:
sudo nano etc/openhab/configurations/rules/home.rules',
'oh_text4_li19' =>'Підключити Arduino із завантаженим скетчем;',
'oh_text4_li20' =>'Надати повний доступ до порту, що буде використовуватися Arduino:
chmod 777 /dev/ttyACM0',
'oh_text4_li21' =>'Перейти до каталогу openHab:
cd /usr/share/openhab/bin',
'oh_text4_li22' =>'Запустити файл .sh:
sudo ./openhab.sh',
'oh_text4_li23' =>'Перейти за адресою: RaspberryPi-IP:8080/openhab.app?sitemap=home',
'rs_title1' =>'Рекомендаційна система (PC) - ',
'rs_text1' =>'це сервіс, який був створений на кафедрі програмних засобів Національного університету «Запорізька політехніка», як частина лабораторії RELDES. Сервіс було розроблено з метою допомогти розробнику вбудованих систем у виборі апаратно-програмних платформ в залежності від вимог розробника до шуканої платформи.',
'rs_text2' =>'Великий вибір серед найпопулярніших платформ',
'rs_text3' =>'База даних налічує в собі понад 40 платформ таких виробників як; Arduino, Raspberry Pi, Texas Instrument, STMicrocontroller, Intel, Netduino, Iskra, BeagleBone',
'rs_title2' =>'Як це працює',
'rs_text4' =>'Рекомендаційна система побудована за принципом систем заснованих на знаннях. Це той випадок, коли розробник сам описує свої потреби, а система, використовуючи базу даних (сформовану на основі знань про платформи з різних джерел), шукає платформи, які відповідають його потребі.
Критерії за якими виконується пошук платформ:',
'rs_tab1_text1' =>'Розробник',
'rs_tab1_text2' =>'рівень знань',
'rs_tab2_text1' =>'Апаратні критерії',
'rs_tab2_text2' =>'кількість аналогових входів;
кількість цифрових входів;
живлення;
сімейство процесорів.',
'rs_tab3_text1' =>'Програмні критерії',
'rs_tab3_text2' =>'мова програмування',
'rs_tab4_text1' =>'Додаткові',
'rs_tab4_text2' =>'ціна,
форм-фактор',
'rs_title3' =>'Етапи роботи з сервісом',
'rs_pic1' =>'<img src="/images/rs_manufacturer_ukr.png"/ width="150" hight="150" alt="KnowlageBase">',
'rs_pic2' =>'<img src="/images/rs_platforms_ukr.png"/ width="150" hight="150" alt="Platforms">',
];
?>
