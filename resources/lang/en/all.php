<?php
return [
    'access' => 'Access control',
    'access_1' => 'The experiment allows studying the principles of creating of access control systems to different rooms using a combination lock.',
    'access_10' => 'Electric lock drive',
    'access_2' => 'The access identifier is the RFID card or keychain and the RFID reader RC522. The RFID reader RC522 reads the radio tags, which are within the range of the reader, permanently.',
    'access_3' => 'RFID reader RC522',
    'access_4' => 'Servo SG90',
    'access_5' => 'The RFID module does the polls with a frequency of 13.56 MHz and interacts with the Arduino NANO v3 controller using the SPI interface. When one of the keys (card or keychain) is moved to the reader, the key is read and compared with the database of users with authorized access in the controller. Users who do not have permission are denied. As the actuator, the servo drive SG90 is used.',
    'access_6' => 'Entrance door',
    'access_7' => 'Electric lock kit',
    'access_8' => 'RFID keys',
    'access_9' => 'Electric lock',
    'apiDesc' => 'RELDES API provide access to resources (data entities) via URI paths. To use a RELDES API, your application will make an HTTP request and parse the response. The response format is JSON. API provides standard HTTP methods like GET, PUT, POST and DELETE. You can use any development language to access the API using HTTP request.',
    'apiDesc1' => 'To use our API, you need to register by going that you will get your API the KEY, you will need to enable it in the query parameters such as: key = YourAPIkey. Also our API uses HTTP Basic Auth, so when you send a request, you must set the string in the request header: "Authorization: Basic" + convert the string "user: password" in base64.',
    'apiDesc10' => 'status - current status of the experiment 1 - busy, 0 - free',
    'apiDesc11' => 'end - the end of the experiment for the user with the current user_id',
    'apiDesc12' => 'Lets take an experiment',
    'apiDesc13' => 'message - a message which can be several answers:',
    'apiDesc14' => 'This user is already in the queue for this experiment,          "Success" - the user has successfully registered in the queue',
    'apiDesc15' => 'status - will be set to false if the user is in the queue, true if it was free to experiment, and he immediately took his',
    'apiDesc16' => 'Experiment\'s time',
    'apiDesc17' => 'Returns a list of data about the start, end, waiting for the experiment',
    'apiDesc18' => 'While waiting in the queue if negative then the current user has already taken the experiment as seconds ago',
    'apiDesc19' => '1 if the user performs the experiment, 0 if there is a queue',
    'apiDesc2' => 'Experiment\'s state',
    'apiDesc20' => 'start of the experiment',
    'apiDesc21' => 'the end of the experiment',
    'apiDesc22' => 'Experiment\'s queue',
    'apiDesc23' => 'It returns a list of all users in the queue for this experiment',
    'apiDesc24' => 'Experiments\'s queues',
    'apiDesc25' => 'It returns a list of all queues on all experiments',
    'apiDesc26' => 'experiment\'s id',
    'apiDesc27' => 'the user who performs the experiment',
    'apiDesc28' => 'Loads the code',
    'apiDesc29' => 'Parameters:',
    'apiDesc3' => 'Occupy experiment',
    'apiDesc30' => 'code for uploading',
    'apiDesc4' => 'Returns the current status of the experiment.',
    'apiDesc5' => 'Request example',
    'apiDesc6' => 'where the first parameter may range between 1 and 4, and the mean number of the experiment',
    'apiDesc7' => 'Response example',
    'apiDesc8' => 'user_id - user on the system which is currently working on an experiment.',
    'apiDesc9' => 'Where',
    'apimethods' => 'API methods:',
    'auth' => 'Authorization',
    'browse' => 'Browse…',
    'clean' => 'Empty code',
    'climate' => 'Climate control',
    'climate_1' => 'This experiment allows studying the method of climate control, based on data from temperature and humidity sensors. Also, the possibility of air quality control implemented, using of sensor for chemical impurities determining in the air.',
    'climate_10' => 'Xiaomi humidity & temperature sensor',
    'climate_11' => 'Everspring Temperature and Humidity Sensor (EVR_ST814)',
    'climate_12' => 'ALQ-CO2 - Air quality and carbon dioxide sensor',
    'climate_13' => 'Humidity / Temperature Sensor - EVR_ST814',
    'climate_2' => 'DHT11 sensor (Digital Temperature Sensor (0-50 ° C) and Humidity (20-90%))',
    'climate_3' => 'Air quality sensor MQ135 (It is designed to determine the content and quantity of harmful and dangerous gases in the air such as: NH3, NOx, alcohol, gasoline, smoke, CO2, etc.. It has a digital (comparator) and analog output)',
    'climate_4' => 'Climate indicators',
    'climate_5' => 'Climate control',
    'climate_6' => 'Temperature on sensor',
    'climate_7' => 'Air humidity on sensor',
    'climate_8' => 'Air quality',
    'climate_9' => 'Ground humidity',
    'close' => 'Close',
    'conf' => 'Configurable experiment',
    'conf_desc' => 'Write your own code or use code templates',
    'copy' => 'Copy',
    'cote' => 'Components of the experiment',
    'cross' => 'Cross-platform',
    'cross_desc' => 'Use any device and operation system',
    'cyber_1' => 'The experiment allows studying the principle of wireless wi-fi sensors operation and investigation their safety usage.',
    'cyber_2' => 'The experiment demonstrates the possibility wireless wi-fi sensors usage for monitoring Smart House system indicators, as well as the results of a wi-fi connection violation due to deauthentication. The possibilities of mobile and cloud technologies application for efficient storage, visualization of data and monitoring of system status are shown.',
    'cyber_3' => 'DHT11 sensor (Digital Temperature Sensor (0-50 ° C) and Humidity (20-90%))',
    'cyber_4' => 'Air quality sensor MQ135 (It is designed to determine the content and quantity of harmful and dangerous gases in the air such as: NH3, NOx, alcohol, gasoline, smoke, CO2, etc.. It has a digital (comparator) and analog output)',
    'cyber_5' => 'Deauthentication is an attack that sends packets to disconnect one or more clients currently connected to a specific access point. In this experiment, the forced client disconnection (capture handshakes WPA / WPA2) is used. Press the ATTACK button, observe a failure in receiving data from the sensor.',
    'cyber_6' => 'Attack',
    'cyber_7' => 'Connection status',
    'cyber_8' => 'Deautentification',
    'cyber_9' => 'Mobile technology',
    'description' => 'Description',
    'display' => 'Display',
    'display_desc_1' => 'In this experiment user is allowed to control LCD and TFT LCD displays. Display has integrated controller and not accessed by Arduino directly. Communication is done vie I2C serial protocol.',
    'display_desc_2' => 'Firstly LiquidCrystal_I2C.h and Wire.h libraries are included. Wire.h implements I2C protocol and LiquidCrystal_I2C.h implements communication with LCD via I2C. LiquidCrystal_I2C class object is created on the beginning of the code with parameters specific to given LCD controller. Changing those is not recommended. The code consists of setup and loop functions. Setup is called only once when board powers on. In this case in the function LCD parameters are set in begin call. Its parameters are numbers of rows and columns. backlight()/noBacklight() function is called to enable/disable LCD’s back light. Loop function is called continuously during all the work time of the board. Cursor position may is set by calling setCursor( column, row ) function. clear() function is called to remove all the symbols from LCD. delay( milliseconds ) function is called to delay activity of the board for stated time in milliseconds. Function print( string ) is called to print symbols starting from cursor position.',
    'display_desc_3' => 'In this example string “Hello, world!” is printed into 1st line of the LCD. Second later string “I am display” is printed in the second line. One more second later LCD is cleared. These actions are repeating in the loop.',
    'display_desc_4' => 'Text scrolling is implemented in this example. On each iteration of the loop cursor position is shifted and text is reprinted from this position.',
    'display_example_1' => 'Hello, world!',
    'display_example_2' => 'Scrolling text',
    'distance' => 'Distance sensor',
    'distance_desc' => 'In this experiment user works with sonic distance sensor. Sensor has 4 pins: vcc, ground, trigger and signal.',
    'distance_desc_1' => 'User receives data from sensor through the serial interface. Serial class is used for that. The code consists of setup and loop functions. Setup is called only once when board powers on. In this function serial interface is initialized with baudrate of 9600 and sensor pins modes are set with pinMode call. Variables with sensor pins are declared before setup function. Loop function is called continuously during all the work time of the board. In this function all the work is done. Distance sensor has two modes: measuring and sending data. To set it in measuring mode pulse with 10 microseconds length must be sent to the sensor (trig pin). It is done by calling digitalWrite function. Its parameters are pin number and pin value. To form the pulse function called multiple times with LOW and HIGH values.',
    'distance_desc_1-1' => 'Delays between calls are made with delayMicroseconds function. To read date from the sensor pulsing is called. This function’s arguments are pin number and expected value (HIGH or LOW). Returned value will represent travel time of sonic signal measured by the sensor. To convert that value to distance functions microsecondsToCentimeters and microsecondsToInches are used. Results are returned to user by print method of serial interface.',
    'distance_desc_2' => 'Distance measurement',
    'distance_desc_3' => 'Distance sensor with servo',
    'distance_desc_4' => 'In this case sensor is attached to servo. It allows user to turn the sensor manually and measure distance to different objects. Servo position is set by write method of Servo object. Angle values are stored in the array. After servo position is set command to measure distance is called. To do so logical 1 pulse with duration of 10 microseconds is sent to the sensor with digitalWrite call. To read the measurements pulseIn is called. Results are sent to the user via serial interface by calling print method.',
    'distance_title' => 'Sonic distance sensor',
    'documentation' => 'documentation',
    'dote' => 'Description of the experiment',
    'emailMessage' => 'Thank you for registering in our system to confirm your registration click on the link:',
    'endTime' => 'End',
    'example' => 'Code example',
    'exit' => 'Logout',
    'expStatuses' => 'Experiment\'s statuses',
    'expUploadCode' => 'Upload code',
    'experiment' => 'Experiment',
    'experiments' => 'Experiments',
    'field' => 'Field of application',
    'field_desc' => 'Decisions support in the design of moving objects control systems based on microcontrollers.',
    'fr' => 'Starting Raspbian OS',
    'fr_desc_1' => 'If you have enabled graphical uploading, you do not need to enter your user password, but if you have changed your password, you may need to enter it. In the case of console mode, login is required',
    'fr_desc_10' => 'Connecting Arduino with Downloaded Sketch',
    'fr_desc_11' => 'You need to connect an Arduino to a Raspberry Pi',
    'fr_desc_12' => 'Get lab sketch # 1 and connected Arduino sensors. Run sketch and leave running.',
    'fr_desc_13' => 'Pull Arduino USB Wire off Computer',
    'fr_desc_14' => 'Insert Arduino USB Wire into Running Raspberry Pi',
    'fr_desc_15' => 'Give full access to the port that the Arduino will use. To do this, write in the terminal: chmod 777 / dev / ttyACM0',
    'fr_desc_1_li1' => 'Browser',
    'fr_desc_1_li2' => 'Explorer',
    'fr_desc_1_li3' => 'Terminal utility',
    'fr_desc_1_li4' => 'Wolfram software',
    'fr_desc_2' => 'By clicking on the menu button (Raspberry Pi logo) you can see the programs installed on the system The menu contains the following sections:',
    'fr_desc_3_li1' => 'Programming: contains programs and tools (Python IDE, Geany, BlueJ, etc.)',
    'fr_desc_3_li10' => 'Run: take action',
    'fr_desc_3_li11' => 'Shutdown: Switch to Card Disconnect Window',
    'fr_desc_3_li2' => 'Office: contains office applications (OpenOffice package)',
    'fr_desc_3_li3' => 'Internet: contains applications and tools to work online',
    'fr_desc_3_li4' => 'Games: contains games (MineCraft)',
    'fr_desc_3_li5' => 'Accessories: contains additional related programs (Archiver, calculator)',
    'fr_desc_3_li6' => 'Sound & Video: contains video and audio players (VLC Player)',
    'fr_desc_3_li7' => 'System Tools: contains system programs (Midnight Commander)',
    'fr_desc_3_li8' => 'Help: Help',
    'fr_desc_3_li9' => 'Preferences: System Settings',
    'fr_desc_4' => 'Basically, most of Raspbian\'s actions (like any Unix-like OS) use the Terminal utility. To start it, click the appropriate icon.',
    'fr_desc_5' => 'You may need to change the system configuration, change the user password, turn on the camera, etc while working. All this can be done using the sudo raspi-config command',
    'fr_desc_5_li' => 'Learn more about menu items:',
    'fr_desc_5_li1' => 'Change User Password',
    'fr_desc_5_li2' => 'Hostname is the name of the computer on the network',
    'fr_desc_5_li3' => 'Boot options - boot settings',
    'fr_desc_5_li4' => 'Localization Options - Select Language and Regional Settings',
    'fr_desc_5_li5' => 'Interfacing Options - Interface Settings (Camera, SSH, VNC, SPI, I2C, Serial, 1-Wire, GPIO)',
    'fr_desc_5_li6' => 'CPU Overclock',
    'fr_desc_5_li7' => 'Advanced Options',
    'fr_desc_5_li8' => 'Update - raspi-config',
    'fr_desc_5_li9' => 'About raspi-config - application information',
    'fr_desc_6' => 'When done, Finish should be selected. The OS will ask for permission to restart. You should agree and wait for the restart to finish. When changing the system settings, care must be taken that the error may lead to undesirable consequences.',
    'fr_desc_7' => 'Setting up the Internet',
    'fr_desc_8' => 'You do not need to do anything else if you are connected to a network that has a DHCP server and automatic address sharing (such as a home network). If DHCP is missing, the network settings can be set using the console. To do this, run the terminal where you want to open the network interface configuration file using the command: sudo nano / etc / network / interfaces. The following should be added to the file: iface <interface> inet static address <ip address> netmask <subnet mask> gateway <gateway address> dns-nameservers <whitespace DNS addresses> auto <interface>, where the interface is a network interface connected to Raspberry Pi (most often eth0); ip address - the address to be assigned; subnet mask - mask; gateway address - The ip address of a computer that serves as the gateway to the network. Then you need to exit saving the changes by pressing Ctrl + X, confirm saving by pressing Y, and then Enter to confirm the file overwriting. After changing the file, you must restart the Raspberry Pi by running the sudo reboot command. To check the network settings, run the ifconfig command',
    'fr_desc_9' => 'To work with a proxy server, some time is required for the files / etc / environment (system-wide proxy settings) and /etc/apt/apt.conf (apt-get batch manager settings). The following should be added to the / etc / environment file: export http_proxy = "http: // host: port", and to the file /etc/apt/apt.conf: Acquire :: http :: proxy "http: // host: port"; . After performing these actions, you will be able to use the network functions, including the apt-get manager.',
    'functional' => 'Functional capabilities',
    'functional_desc' => 'The laboratory provides users with information on software and hardware solutions for further implementation; allows them to obtain skills in embedded systems programming.',
    'ide' => 'Arduino Development Environment',
    'ide_extra' => 'More information',
    'ide_extra_desc' => '<h3>Sketchbook</h3> <p> The Arduino environment uses the concept of a sketchbook: a standard place to store your programs (or sketches). The sketches in your sketchbook can be opened from the File > Sketchbook menu or from the Open button on the toolbar. The first time you run the Arduino software, it will automatically create a directory for your sketchbook. You can view or change the location of the sketchbook location from with the Preferences dialog. </p> <h3>Tabs, Multiple Files, and Compilation</h3> <p> Allows you to manage sketches with more than one file (each of which appears in its own tab). These can be normal Arduino code files (no extension), C files (.c extension), C++ files (.cpp), or header files (.h). </p> <h3>Uploading</h3> <p> Before uploading your sketch, you need to select the correct items from the Tools > Board and Tools > Serial Port menus. The boards are described below. On the Mac, the serial port is probably something like /dev/tty.usbmodem241 (for an Uno or Mega2560 or Leonardo) or /dev/tty.usbserial-1B1 (for a Duemilanove or earlier USB board), or /dev/tty.USA19QW1b1P1.1 (for a serial board connected with a Keyspan USB-to-Serial adapter). On Windows, it\'s probably COM1 or COM2 (for a serial board) or COM4, COM5, COM7, or higher (for a USB board) - to find out, you look for USB serial device in the ports section of the Windows Device Manager. On Linux, it should be /dev/ttyUSB0, /dev/ttyUSB1 or similar. </p> <p> Once you\'ve selected the correct serial port and board, press the upload button in the toolbar or select the Upload item from the File menu. Current Arduino boards will reset automatically and begin the upload. With older boards (pre-Diecimila) that lack auto-reset, you\'ll need to press the reset button on the board just before starting the upload. On most boards, you\'ll see the RX and TX LEDs blink as the sketch is uploaded. The Arduino environment will display a message when the upload is complete, or show an error. </p> <p> When you upload a sketch, you\'re using the Arduino bootloader, a small program that has been loaded on to the microcontroller on your board. It allows you to upload code without using any additional hardware. The bootloader is active for a few seconds when the board resets; then it starts whichever sketch was most recently uploaded to the microcontroller. The bootloader will blink the on-board (pin 13) LED when it starts (i.e. when the board resets). </p> <h3>Libraries</h3> <p> Libraries provide extra functionality for use in sketches, e.g. working with hardware or manipulating data. To use a library in a sketch, select it from the Sketch > Import Library menu. This will insert one or more #include statements at the top of the sketch and compile the library with your sketch. Because libraries are uploaded to the board with your sketch, they increase the amount of space it takes up. If a sketch no longer needs a library, simply delete its #include statements from the top of your code. </p> <p> There is a list of libraries in the reference. Some libraries are included with the Arduino software. Others can be downloaded from a variety of sources. Starting with version 1.0.5 of the IDE, you do can import a library from a zip file and use it in an open sketch. </p> <h3>Third-Party Hardware</h3> <p> Support for third-party hardware can be added to the hardware directory of your sketchbook directory. Platforms installed there may include board definitions (which appear in the board menu), core libraries, bootloaders, and programmer definitions. To install, create the hardware directory, then unzip the third-party platform into its own sub-directory. (Don\'t use "arduino" as the sub-directory name or you\'ll override the built-in Arduino platform.) To uninstall, simply delete its directory. </p> <h3>Serial Monitor</h3> <p> Displays serial data being sent from the Arduino board (USB or serial board). To send data to the board, enter text and click on the "send" button or press enter. Choose the baud rate from the drop-down that matches the rate passed to Serial.begin in your sketch. Note that on Mac or Linux, the Arduino board will reset (rerun your sketch from the beginning) when you connect with the serial monitor. </p> <p> You can also talk to the board from Processing, Flash, MaxMSP, etc (see the interfacing page for details). </p> <h3>Preferences</h3> <p> Some preferences can be set in the preferences dialog (found under the Arduino menu on the Mac, or File on Windows and Linux). The rest can be found in the preferences file, whose location is shown in the preference dialog. </p> <h3>Language Support</h3> <p> The Arduino 1.0.1 software environment has been translated into 30+ different languages. By default, the IDE loads in the language selected by your operating system. (Note: on Windows and possibly Linux, this is determined by the locale setting which controls currency and date formats, not by the language the operating system is displayed in.) </p> <p> If you would like to change the language manually, start the Arduino software and open the Preferences window. Next to the Editor Language there is a dropdown menu of currently supported languages. Select your preferred language from the menu, and restart the software to use the selected language. If your preferred language is not supported, the IDE will default to English. </p> <p> You can return Arduino to its default setting of selecting its language based on your operating system by selecting System Default from the Editor Language drop-down. This setting will take effect when you restart the Arduino software. Similarly, after changing your operating system\'s settings, you must restart the Arduino software to update it to the new default language. </p> <h3>Boards</h3> <p> The board selection has two effects: it sets the parameters (e.g. CPU speed and baud rate) used when compiling and uploading sketches; and sets and the file and fuse settings used by the burn bootloader command. Some of the board definitions differ only in the latter, so even if you\'ve been uploading successfully with a particular selection you\'ll want to check it before burning the bootloader. </p>',
    'ide_info' => 'Overview',
    'ide_info_desc' => '<p> The Arduino development environment contains a text editor for writing code, a message area, a text console, a toolbar with buttons for common functions, and a series of menus. It connects to the Arduino hardware to upload programs and communicate with them. </p> <p> Software written using Arduino are called sketches. These sketches are written in the text editor. Sketches are saved with the file extension .ino. It has features for cutting/pasting and for searching/replacing text. The message area gives feedback while saving and exporting and also displays errors. The console displays text output by the Arduino environment including complete error messages and other information. The bottom righthand corner of the window displays the current board and serial port. The toolbar buttons allow you to verify and upload programs, create, open, and save sketches, and open the serial monitor: </p> <ul> <li>Verify – Checks your code for errors;</li> <li>Upload – Compiles your code and uploads it to the Arduino I/O board. See uploading below for details;</li> <li>New – Creates a new sketch;</li> <li>Open – Presents a menu of all the sketches in your sketchbook. Clicking one will open it within the current window;</li> <li>Save – Saves your sketch;</li> <li>Serial Monitor – Opens the serial monitor.</li> </ul>',
    'ide_menu' => '<p style=\'font-weight: bold;\'> Additional commands are found within the five menus: File, Edit, Sketch, Tools, Help. The menus are context sensitive which means only those items relevant to the work currently being carried out are available. </p> <h4>Edit:</h4> <ul> <li>Copy for Forum (copies the code of your sketch to the clipboard in a form suitable for posting to the forum, complete with syntax coloring);</li> <li>Copy as HTML (copies the code of your sketch to the clipboard as HTML, suitable for embedding in web pages);</li> </ul> <h4>Sketch:</h4> <ul> <li>Verify/Compile (checks your sketch for errors);</li> <li>Show Sketch Folder (opens the current sketch folder);</li> <li>Add File... (adds a source file to the sketch (it will be copied from its current location). The new file appears in a new tab in the sketch window. Files can be removed from the sketch using the tab menu);</li> <li>Import Library (adds a library to your sketch by inserting #include statements at the start of your code. For more details, see libraries below. Additionally, with version 1.0.5 and later of the IDE, you can import a library from a .zip file).</li> </ul> <h4>Tools:</h4> <ul> <li>Auto Format (this formats your code nicely: i.e. indents it so that opening and closing curly braces line up, and that the statements inside curly braces are indented more);</li> <li>Archive Sketch (archives a copy of the current sketch in .zip format. The archive is placed in the same directory as the sketch);</li> <li>Board (select the board that you\'re using. See below for descriptions of the various boards);</li> <li>Serial Port (this menu contains all the serial devices (real or virtual) on your machine. It should automatically refresh every time you open the top-level tools menu);</li> <li>Programmer (for selecting a harware programmer when programming a board or chip and not using the onboard USB-serial connection. Normally you won\'t need this, but if you\'re burning a bootloader to a new microcontroller, you will use this);</li> <li>Burn Bootloader (the items in this menu allow you to burn a bootloader onto the microcontroller on an Arduino board. This is not required for normal use of an Arduino board but is useful if you purchase a new ATmega microcontroller (which normally come without a bootloader). Ensure that you\'ve selected the correct board from the Boards menu before burning the bootloader).</li> </ul>',
    'illum_1' => 'The experiment give possibility to study the basics of the loads driver functioning and the principle of multicolored (RGB) LED lighting systems creating, as well as RGB LED tape control',
    'illum_10' => 'RGB color',
    'illum_11' => 'Lighting can be set not only by color, but also by mood. Choose the mood you want and evaluate the color of the lighting.',
    'illum_12' => 'Choose your mood',
    'illum_13' => 'Delight',
    'illum_14' => 'Relax',
    'illum_15' => 'Sorrow',
    'illum_16' => 'Turn on the switch and evaluate the result at different speeds.',
    'illum_17' => 'Execute scenario with random colors',
    'illum_18' => 'RGB controller',
    'illum_19' => 'The circuit of components connection',
    'illum_2' => 'Arduino NANO has the ability to generate a PWM (Pulse Wide Modulation) signal on some pins, which is transmitted to the inputs of the L298N load driver. The L298N module acts as RGB controller and gives possibility to control four DC load channels, depending on the PWM input signal. The level of output DC on the channels of RGB tape is proportional to the input channel. The multi-colored (RGB) LED tape (depending on the type of tape) has 4 inputs (RED, GREEN, BLUE, + 12V). Depending on the level of DC, the brightness of the required color sets on the LEDs. * The L298N load driver has the ability to control loads with a current of 2A. Pay attention to the characteristics of the LED tape.',
    'illum_3' => 'Loads driver L298 (5-35V, 2A)',
    'illum_4' => 'RGB LED tape',
    'illum_5' => 'DC Power Supply 5V, 1А and 12V, 4А',
    'illum_6' => 'Color selection',
    'illum_7' => 'Selection of mood',
    'illum_8' => 'Color change',
    'illum_9' => 'Select the desired color of the light on the tape and click "choose".',
    'illumination' => 'Illumination control',
    'infoDescription' => 'Description of the experiment scenarios',
    'infoFirst' => '1. Select experiment',
    'infoFirst_desc' => 'List of available experiments:',
    'infoFourth' => '4. See results',
    'infoFourth_desc' => 'During the experiment performance, you can see the results received from the server.',
    'infoSamples' => 'Examples of the experiment program codes',
    'infoSchema' => 'Scheme of the experiment',
    'infoSecond' => '2. Read about it',
    'infoSecond_desc' => 'Each experiment page contains:',
    'infoThird' => '3. Run the sample code',
    'infoThird_desc' => 'On the page with the experiment you can use ready examples of program codes or write your own.',
    'infoTitle' => 'User manual',
    'led' => 'LED',
    'led_desc_1' => 'This experiment allows users to control LEDs with Arduino board. LEDs are connected to digital pins of the board. Resistors are used to restrict the current flowing through the diodes. Diodes have common ground.',
    'led_desc_10' => 'In this experiment, checked the serviceability LEDs with an analog port',
    'led_desc_2' => 'The code consists of setup and loop functions. Setup is called only once when board powers on. In this case in the function pins from 2 to 5 are set up in output mode. Function pinMode is used for that. Its firs argument is pin number and second is pin mode. Loop function is called continuously during all the work time of the board. In this function all the work is done. To control diodes’ brightness analogWrite call is used. Its arguments are pin number and voltage value. Voltage range is 0-5V. Voltage value is not used directly as parameter of analogWrite, value ranged from 0 to 255 is used instead. Each value in this range is corresponded to voltage from 0 to 5V. It is done by so called pulse width modulation (PWM). To make it possible for user to see diodes brightness change function delay is called. It stops board’s work for amount of time (in ms) stated as argument of the function.',
    'led_desc_3' => 'In this example diodes are light up and down one by one with delay of 700ms.',
    'led_desc_4' => 'Running lights',
    'led_desc_5' => 'In this example all LEDs are light up by for loop. Second for loops dims LEDs down. The loops are repeating.',
    'led_desc_6' => 'Brightness change',
    'led_desc_7' => 'In this example brightness of each LED is changed smoothly by changing voltage from 0 to 5V in for loop.',
    'led_desc_8' => 'Sequential lights',
    'led_desc_9' => 'Simalation defective LEDs',
    'light_1' => 'The experiment gives possibility to study the basics of dimmer’s operation using the example of control of a white LED strip. The dimmer allows you to control the electrical power and thus control the level of illumination. The experiment also makes it possible to reproduce the automatic control algorithm under the necessary conditions.',
    'light_10' => 'Remotely controlled dimmer for LEDs',
    'light_11' => 'LED tape (White)',
    'light_2' => 'Arduino Nano receives a numerical value for the required level of illumination and generates a PWM (Pulse Wide Modulation) signal for the load driver. The load driver controls voltage on the LEDs. Thus, the illumination level is controlled. The load driver performs the dimmer function. The dimmer, depending on the type, can control the alternative and direct voltage.',
    'light_3' => 'LED tape',
    'light_4' => 'Light level control',
    'light_5' => 'Setting the illumination',
    'light_6' => 'Drag the slider to change the light level (from 0 to 100%) and analyze the data from the light sensor.',
    'light_7' => 'Set the time of day and estimate the level of illumination.',
    'light_8' => 'AC Voltage Dimmer',
    'light_9' => 'DC Voltage Dimmer (industrial)',
    'lighting' => 'Lighting control',
    'log_in' => 'Log in',
    'login' => 'login',
    'mailer' => 'Mailer',
    'mega_extra' => 'Specification',
    'mega_extra_desc' => '<div class="spoiler-body collapse"> <h4>Power</h4> <p> The Arduino Mega can be powered via the USB connection or with an external power supply. The power source is selected automatically. </p> <p> External (non-USB) power can come either from an AC-to-DC adapter (wall-wart) or battery. The adapter can be connected by plugging a 2.1mm center-positive plug into the board\'s power jack. Leads from a battery can be inserted in the Gnd and Vin pin headers of the POWER connector. </p> <p> The board can operate on an external supply of 6 to 20 volts. If supplied with less than 7V, however, the 5V pin may supply less than five volts and the board may be unstable. If using more than 12V, the voltage regulator may overheat and damage the board. The recommended range is 7 to 12 volts. </p> <p> The power pins are as follows: <ul> <li><strong>VIN.</strong> The input voltage to the Arduino board when it\'s using an external power source (as opposed to 5 volts from the USB connection or other regulated power source). You can supply voltage through this pin, or, if supplying voltage via the power jack, access it through this pin.</li> <li><strong>5V.</strong> This pin outputs a regulated 5V from the regulator on the board. The board can be supplied with power either from the DC power jack (7 - 12V), the USB connector (5V), or the VIN pin of the board (7-12V). Supplying voltage via the 5V or 3.3V pins bypasses the regulator, and can damage your board. We don\'t advise it.</li> <li><strong>3V3.</strong> A 3.3 volt supply generated by the on-board regulator. Maximum current draw is 50 mA.</li> <li><strong>GND.</strong> Ground pins.</li> <li><strong>IOREF.</strong> This pin on the Arduino board provides the voltage reference with which the microcontroller operates. A properly configured shield can read the IOREF pin voltage and select the appropriate power source or enable voltage translators on the outputs for working with the 5V or 3.3V.</li> </ul> </p> <h4>Memory</h4> <p> The ATmega2560 has 256 KB of flash memory for storing code (of which 8 KB is used for the bootloader), 8 KB of SRAM and 4 KB of EEPROM (which can be read and written with the EEPROM library). </p> <h4>Input and Output</h4> <p> Each of the 54 digital pins on the Mega can be used as an input or output, using pinMode(), digitalWrite(), and digitalRead() functions. They operate at 5 volts. Each pin can provide or receive a maximum of 40 mA and has an internal pull-up resistor (disconnected by default) of 20-50 kOhms. In addition, some pins have specialized functions: <ul> <li><strong>Serial: 0 (RX) and 1 (TX); Serial 1: 19 (RX) and 18 (TX); Serial 2: 17 (RX) and 16 (TX); Serial 3: 15 (RX) and 14 (TX).</strong> Used to receive (RX) and transmit (TX) TTL serial data. Pins 0 and 1 are also connected to the corresponding pins of the ATmega16U2 USB-to-TTL Serial chip.</li> <li><strong>External Interrupts: 2 (interrupt 0), 3 (interrupt 1), 18 (interrupt 5), 19 (interrupt 4), 20 (interrupt 3), and 21 (interrupt 2).</strong> These pins can be configured to trigger an interrupt on a low value, a rising or falling edge, or a change in value. See the attachInterrupt() function for details.</li> <li><strong>PWM: 2 to 13 and 44 to 46.</strong> Provide 8-bit PWM output with the analogWrite() function.</li> <li><strong>SPI: 50 (MISO), 51 (MOSI), 52 (SCK), 53 (SS).</strong> These pins support SPI communication using the SPI library. The SPI pins are also broken out on the ICSP header, which is physically compatible with the Uno, Duemilanove and Diecimila.</li> <li><strong>LED: 13.</strong> There is a built-in LED connected to digital pin 13. When the pin is HIGH value, the LED is on, when the pin is LOW, it\'s off.</li> <li><strong>TWI: 20 (SDA) and 21 (SCL).</strong> Support TWI communication using the Wire library. Note that these pins are not in the same location as the TWI pins on the Duemilanove or Diecimila.</li> </ul> <p> The Mega2560 has 16 analog inputs, each of which provide 10 bits of resolution (i.e. 1024 different values). By default they measure from ground to 5 volts, though is it possible to change the upper end of their range using the AREF pin and analogReference() function. </p> <p> There are a couple of other pins on the board: <ul> <li><strong>AREF.</strong> Reference voltage for the analog inputs. Used with analogReference().</li> <li><strong>Reset.</strong> Bring this line LOW to reset the microcontroller. Typically used to add a reset button to shields which block the one on the board.</li> </ul> </p> <h4>Communication</h4> <p> The Arduino Mega2560 has a number of facilities for communicating with a computer, another Arduino, or other microcontrollers. The ATmega2560 provides four hardware UARTs for TTL (5V) serial communication. An ATmega16U2 (ATmega 8U2 on the revision 1 and revision 2 boards) on the board channels one of these over USB and provides a virtual com port to software on the computer (Windows machines will need a .inf file, but OSX and Linux machines will recognize the board as a COM port automatically. The Arduino software includes a serial monitor which allows simple textual data to be sent to and from the board. The RX and TX LEDs on the board will flash when data is being transmitted via the ATmega8U2/ATmega16U2 chip and USB connection to the computer (but not for serial communication on pins 0 and 1). </p> <p> A SoftwareSerial library allows for serial communication on any of the Mega2560\'s digital pins. </p> <p> The ATmega2560 also supports TWI and SPI communication. The Arduino software includes a Wire library to simplify use of the TWI bus; see the documentation for details. For SPI communication, use the SPI library. </p> <h4>Programming</h4> <p> The Arduino Mega can be programmed with the Arduino software (download). For details, see the reference and tutorials. </p> <p> The ATmega2560 on the Arduino Mega comes preburned with a bootloader that allows you to upload new code to it without the use of an external hardware programmer. It communicates using the original STK500 protocol. </p> <p> You can also bypass the bootloader and program the microcontroller through the ICSP (In-Circuit Serial Programming) header using Arduino ISP or similar. </p> <p> The ATmega16U2 (or 8U2 in the rev1 and rev2 boards) firmware source code is available in the Arduino repository. The ATmega16U2/8U2 is loaded with a DFU bootloader. You can then use Atmel\'s FLIP software (Windows) or the DFU programmer (Mac OS X and Linux) to load a new firmware. Or you can use the ISP header with an external programmer (overwriting the DFU bootloader). See this user-contributed tutorial for more information. </p> <h4>Automatic (Software) Reset</h4> <p> Rather then requiring a physical press of the reset button before an upload, the Arduino Mega2560 is designed in a way that allows it to be reset by software running on a connected computer. One of the hardware flow control lines (DTR) of the ATmega8U2 is connected to the reset line of the ATmega2560 via a 100 nanofarad capacitor. When this line is asserted (taken low), the reset line drops long enough to reset the chip. The Arduino software uses this capability to allow you to upload code by simply pressing the upload button in the Arduino environment. This means that the bootloader can have a shorter timeout, as the lowering of DTR can be well-coordinated with the start of the upload. </p> <p> This setup has other implications. When the Mega2560 is connected to either a computer running Mac OS X or Linux, it resets each time a connection is made to it from software (via USB). For the following half-second or so, the bootloader is running on the Mega2560. While it is programmed to ignore malformed data (i.e. anything besides an upload of new code), it will intercept the first few bytes of data sent to the board after a connection is opened. If a sketch running on the board receives one-time configuration or other data when it first starts, make sure that the software with which it communicates waits a second after opening the connection and before sending this data. </p> <p> The Mega2560 contains a trace that can be cut to disable the auto-reset. The pads on either side of the trace can be soldered together to re-enable it. It\'s labeled "RESET-EN". You may also be able to disable the auto-reset by connecting a 110 ohm resistor from 5V to the reset line; see this forum thread for details. </p> <h4>USB Overcurrent Protection</h4> <p> The Arduino Mega2560 has a resettable polyfuse that protects your computer\'s USB ports from shorts and overcurrent. Although most computers provide their own internal protection, the fuse provides an extra layer of protection. If more than 500 mA is applied to the USB port, the fuse will automatically break the connection until the short or overload is removed. </p> <h4>Physical Characteristics and Shield Compatibility</h4> <p> The maximum length and width of the Mega2560 PCB are 4 and 2.1 inches respectively, with the USB connector and power jack extending beyond the former dimension. Three screw holes allow the board to be attached to a surface or case. Note that the distance between digital pins 7 and 8 is 160 mil (0.16"), not an even multiple of the 100 mil spacing of the other pins. </p> <p> The Mega2560 is designed to be compatible with most shields designed for the Uno, Diecimila or Duemilanove. Digital pins 0 to 13 (and the adjacent AREF and GND pins), analog inputs 0 to 5, the power header, and ICSP header are all in equivalent locations. Further the main UART (serial port) is located on the same pins (0 and 1), as are external interrupts 0 and 1 (pins 2 and 3 respectively). SPI is available through the ICSP header on both the Mega2560 and Duemilanove / Diecimila. Please note that I2C is not located on the same pins on the Mega (20 and 21) as the Duemilanove / Diecimila (analog inputs 4 and 5). </p> </div>',
    'mega_info' => 'Overview',
    'mega_info_desc' => 'The Arduino Mega 2560 is a microcontroller board based on the ATmega2560 (<a target=\'_blank\' href=\'http://www.atmel.com/Images/Atmel-2549-8-bit-AVR-Microcontroller-ATmega640-1280-1281-2560-2561_datasheet.pdf\'>datasheet, pdf</a>). It has 54 digital input/output pins (of which 15 can be used as PWM outputs), 16 analog inputs, 4 UARTs (hardware serial ports), a 16 MHz crystal oscillator, a USB connection, a power jack, an ICSP header, and a reset button. It contains everything needed to support the microcontroller; simply connect it to a computer with a USB cable or power it with a AC-to-DC adapter or battery to get started. The Mega is compatible with most shields designed for the Arduino Duemilanove or Diecimila.',
    'mega_summary' => '<tr><td>Microcontroller</td><td>ATmega2560</td></tr> <tr><td>Operating Voltage</td><td>5V</td></tr> <tr><td>Input Voltage (recommended)</td><td>7-12V</td></tr> <tr><td>Input Voltage (limits)</td><td>6-20V</td></tr> <tr><td>Digital I/O Pins</td><td>54 (of which 15 provide PWM output)</td></tr> <tr><td>Analog Input Pins</td><td>16</td></tr> <tr><td>DC Current per I/O Pin</td><td>40 mA</td></tr> <tr><td>DC Current for 3.3V Pin</td><td>50 mA</td></tr> <tr><td>Flash Memory</td><td>256 KB of which 8 KB used by bootloader</td></tr> <tr><td>SRAM</td><td>8 KB</td></tr> <tr><td>EEPROM</td><td>4 KB</td></tr> <tr><td>Clock Speed</td><td>16 MHz</td></tr>',
    'name' => 'first name',
    'oh_li1' => 'to all items (access can be contacted by name);',
    'oh_li2' => 'to all statuses and teams;',
    'oh_li3' => 'to standard actions to perform various operations.',
    'oh_li4' => 'from the rules;',
    'oh_li5' => 'from the XMPP console;',
    'oh_li6' => 'from the entries in the Google Calendar.',
    'oh_text' => 'OpenHAB (Open Home Automation Bus) - a Java-based open source smart house implementation project, distributed under the GPLv3 license, and Jetty is used to organize the work of the web-interface. This open platform is capable of performing functions such as turning on and off the light, controlling sockets, and so on. OpenHAB provides tools for organizing the work of various systems, equipment and home automation interfaces. At the same time OpenHAB does not depend on protocols and equipment, providing a separate level of abstraction, which allows you to interact with different types of devices and software. To determine the control logic used scripts, written in a special subject-oriented programming language, developed with the help of Eclipse -Xtext. The main OpenHAB service is the event bus. Modules that do not require state tracking use this bus to share event information with other modules. There are two main types of events: 1. Commands that initiate any action or change the state of a particular item or device. 2. Status updates that report changes in the state of a particular item or device. Binding protocols that communicate with real devices should communicate with each other precisely through the event bus. This ensures communication between the modules. OpenHAB uses a very powerful expression language, which defines scenarios. A script or script is a code block defined by the user and can be called and used in different places. Scripts are placed in the openhab / configurations / scripts folder. The demo.script demo file is in the workspace. Scripts may also be inside a rule file in the openhab / configurations / rules folder: they are used to define the rule execution block. Each rule consists of two parts: one contains action switches, in other scripts - for their execution. For efficient use of scripts OpenHAB provides access:',
    'oh_text2' => 'The script is identified by the name (in the demo.script file, the name of the demo script). Each script always returns the value that is the result of the last expression contained therein. Scripts may be called:',
    'oh_text3' => 'Installation and configuration OpenHAB on Raspberry Pi',
    'oh_text4' => 'To install OpenHAB on Raspberry Pi, you must perform a sequence of actions and commands (using a terminal) as described below.',
    'oh_text4_li1' => 'Download key: wget -qO - \'https://bintray.com/user/downloadSubjectPublicKey?username= openhab \'| sudo apt-key add -',
    'oh_text4_li10' => 'Overload systemd: sudo systemctl daemon-reload',
    'oh_text4_li11' => 'Add port to be used with Arduino: sudo nano /usr/share/openhab/bin/openhab.sh In the section "JAVA_ARGS_DEFAULT" add to the end',
    'oh_text4_li12' => 'Overload OpenHAB: sudo service openhab restart',
    'oh_text4_li13' => 'Write code to receive data from Arduino: sudo nano /etc/openhab/configurations/items/home.items',
    'oh_text4_li14' => 'Create interface for displaying data: sudo nano /etc/openhab/configurations/sitemaps/home.sitemap',
    'oh_text4_li15' => 'Find the Java process and remember its number: top',
    'oh_text4_li16' => 'Stop the Java process. For example, the Java process number is 3234, then: kill 3234',
    'oh_text4_li17' => 'Rename the openhab_default.cfg file at openhab.cfg in /etc/openhab/configurations/',
    'oh_text4_li18' => 'Create OpenHAB rule for sensor control: sudo nano etc / openhab / configurations / rules / home.rules',
    'oh_text4_li19' => 'Connect Arduino with a loaded sketch;',
    'oh_text4_li2' => 'Install the OpenHAB Repository: echo "deb http://dl.bintray.com/openhab/apt-repo stable main" | sudo tee /etc/apt/sources.list.d/openhab.list',
    'oh_text4_li20' => 'Provide full access to the port to be used by Arduino: chmod 777 /dev/ttyACM0',
    'oh_text4_li21' => 'Go to the openHab directory: cd /usr/share/openhab/bin',
    'oh_text4_li22' => 'Run the .sh file: sudo ./openhab.sh',
    'oh_text4_li23' => 'Go to: RaspberryPi-IP: 8080/openhab.app?sitemap = home',
    'oh_text4_li3' => 'Update system files: sudo apt-get update',
    'oh_text4_li4' => 'Install OpenHAB: sudo apt-get install openhab-runtime',
    'oh_text4_li5' => 'Add a user to the group: sudo usermod -a g openhab pi',
    'oh_text4_li6' => 'Run OpenHAB: sudo systemctl enable openhab',
    'oh_text4_li7' => 'Install the add-on for GPIO: sudo apt-get install openhab-addon-io-gpio sudo apt-get install openhab-addon-binding-gpio',
    'oh_text4_li8' => 'Install add-ons for working with ports: sudo apt-get install openhab-addons-binding-serial',
    'oh_text4_li9' => 'Specify a user name and group name : sudo nano /etc/default/openhab sudo nano /usr/lib/systemd/system/openhab.service',
    'oh_title' => 'Integration of Smart House subsystems based on OpenHAB platform',
    'passwd' => 'password',
    'passwd_repeat' => 'repeat password',
    'personal' => 'personal use',
    'pi_install_desc' => 'There are two ways to install Raspbian on Raspberry Pi:',
    'pi_install_desc_li1' => 'Download NOOBS from the official site to your MicroSD memory card and install;',
    'pi_install_desc_li2' => 'Mounting a Raspbian OS file on a MicroSD memory card. In this case, it will be possible to start working immediately after the Raspberry Pi is turned on.',
    'pi_install_v1' => 'An example of installing Raspbian OS using NOOBS',
    'pi_install_v1_desc_1' => 'You must download the package from the official site https://www.raspberrypi.org/downloads/noobs/. You must select NOOBS \'Offline and network install\' for installation without the Internet or NOOBS LITE \'Network install only\' for installation with the Internet.',
    'pi_install_v1_desc_2' => 'Before formatting NOOBS files to a microSD card, it must be formatted in the FAT32 file system. Next, unzip the NOOBS archive to your microSD memory card. The next step is to connect the peripherals to the Raspberry Pi: USB keyboard, USB mouse, monitor (via HDMI), and you must insert the microSD card into the appropriate slot. Last but not least, the MicroUSB power is plugged in. In the window that appears, select Raspbian OS (first option). The second option is to split sections of the memory card manually, the third option is to download directly to Scratch, a program for creating computer graphics and animations. You need to click “Install” and confirm the recording to the MicroSD memory card. The installation and reboot process must be completed. In the Configuration Tool window (you can change the settings later), select the "Enable boot to Desktop" option and confirm the selection, which will make LXDE the default boot interface. Next, click Done and agree to restart. You will then be ready to go.',
    'pi_install_v2' => 'An example of installing Raspbian using file-image mounting',
    'pi_install_v2_desc2_li1' => 'you need to unzip the image file on your computer',
    'pi_install_v2_desc2_li2' => 'You should format your memory card with a standard Windows tool',
    'pi_install_v2_desc2_li3' => 'Next, in Win32DiskImager you must select a Raspbian OS file (for example: "2017-09-07-raspbian-stretch.img")',
    'pi_install_v2_desc2_li4' => 'In the Device section, select the name of the microSD memory card. You should be careful if you make a mistake, you can harm the hard disk',
    'pi_install_v2_desc2_li5' => 'Finally select Write \'and wait for the writing process to complete. The approximate recording time is 5-10 minutes',
    'pi_install_v2_desc3' => 'You must then connect the peripherals to the Raspberry Pi: USB keyboard, USB mouse, monitor (via HDMI), and insert the microSD card into the appropriate slot. Last but not least, the MicroUSB power is plugged in.',
    'pi_install_v2_desc3_li1' => 'Raspbian OS will be downloaded and ready to go.',
    'pi_install_v2_desc3_li2' => 'If using Unix-like OS:',
    'pi_install_v2_desc3_li3' => 'should format microSD memory card in FAT 32 / ext2',
    'pi_install_v2_desc3_li4' => 'Execute command: sudo dd bs = 4m if = / home / user / raspbian.img of = / dev / disk1;',
    'pi_install_v2_desc3_li5' => 'Raspbian OS will be downloaded and ready to go. It is important to remember that the Raspberry Pi starts immediately after connecting MicroUSB, and that the Raspberry Pi should be switched off as follows:',
    'pi_install_v2_desc3_li6' => 'Complete all actions',
    'pi_install_v2_desc3_li7' => 'Click on Raspberry Pi logo in the upper left corner',
    'pi_install_v2_desc3_li8' => 'Select Shutdown and in the new window confirm - Shutdown',
    'pi_install_v2_desc3_li9' => 'Only after the Raspberry Pi is disconnected can you disconnect the MicroUSB cord and change the composition of the peripherals connected to the Raspberry Pi.',
    'pi_install_v2_desc_1' => 'You must first download the OS from the official site: https://www.raspberrypi.org/downloads/raspbian/. We recommend choosing "Raspbian Stretch With Desktop".',
    'pi_install_v2_desc_2' => 'You also need to install Win32DiskImager (https://sourceforge.net/projects/win32diskimager/) on your computer and use it to write a Raspbian OS file to your microSD:',
    'pi_ul_li1' => 'Raspbian (Debian modification)',
    'pi_ul_li2' => 'Pidora (Fedora mofification)',
    'pi_ul_li3' => 'Arch Linux ARM',
    'pi_ul_li4' => 'Kali Linux',
    'platforms' => 'Platforms',
    'presence' => 'Presence control',
    'presence_1' => 'The experiment allows studying the principles of presence monitoring systems and security systems operation by changing the mode of operation of the subsystem. The possibility of motion control in several areas has been realized.',
    'presence_2' => 'PIR sensor (passive infrared sensor, often used in alarm systems)',
    'presence_3' => 'Interior door',
    'queue' => 'Queue',
    'recommendation' => 'Recommendation system',
    'recommendation_over' => 'Overview',
    'recommendation_select' => 'Platform selection',
    'register' => 'Register',
    'registration' => 'Registration',
    'reldes' => 'Remote laboratory',
    'reldes_desc' => 'RELDES (REmote Laboratory of Embedded Systems Design) – developed at Software Tools department of Zaporizhzhya National Technical University, Ukraine. Provides remote access to Arduino based experimental equipment.',
    'rp' => 'Real project',
    'rpi_sd' => 'The Raspberry Pi is a bank card-sized single-board computer, originally designed as a budget system for computer science education, which has subsequently become much more widely used and popular. The first versions were created in 2011. Built on an ARM architecture processor. The Raspberry Pi works mainly on Linux-based operating systems such as:',
    'rs_pic1' => '<img src="/assets/images/rs_knowbase_eng.png"/ width="150" hight="150" alt="KnowlageBase">',
    'rs_pic2' => '<img src="/assets/images/rs_platforms_eng.png"/ width="150" hight="150" alt="Platforms">',
    'rs_tab1_text1' => 'Developer',
    'rs_tab1_text2' => 'knowledge level',
    'rs_tab2_text1' => 'Hardware criterias',
    'rs_tab2_text2' => 'analog input; digital input; power; processor family.',
    'rs_tab3_text1' => 'Software criterias',
    'rs_tab3_text2' => 'language',
    'rs_tab4_text1' => 'Additional',
    'rs_tab4_text2' => 'price; form-factor.',
    'rs_text1' => 'is a service created at the Software Department of the Zaporozhzhia Polytechnic National University within the RELDES laboratory. The service was designed to help embedded system designers choose hardware-software platforms, depending on the developer\'s requirements for the platform they are looking for.',
    'rs_text2' => 'Great choice among the most popular platforms',
    'rs_text3' => 'The database includes more than 40 platforms produced by the different companies, such as: Arduino, Raspberry Pi, Texas Instrument, STMicrocontroller, Intel, Netduino, Iskra, BeagleBone',
    'rs_text4' => 'The recommendation system is built based on the principle of knowledge-based systems. This is a case where the developer describes his needs himself, and the system, using a database (formed on the basis of knowledge about platforms from different sources), looks for platforms that meet his needs. Platform search criteria:',
    'rs_title1' => 'Recommendation System (RS) -',
    'rs_title2' => 'How is it works?',
    'rs_title3' => 'STAGES OF WORKING WITH THE SERVICE',
    'run' => 'Run',
    'safety_1' => 'Arduino NANO has the ability to generate a PWM (Pulse Wide Modulation) signal on some pins, which is transmitted to the inputs of the L298N load driver. The L298N module acts as RGB controller and gives possibility to control four DC load channels, depending on the PWM input signal. The level of output DC on the channels of RGB tape is proportional to the input channel. The multi-colored (RGB) LED tape (depending on the type of tape) has 4 inputs (RED, GREEN, BLUE, + 12V). Depending on the level of DC, the brightness of the required color sets on the LEDs. * The L298N load driver has the ability to control loads with a current of 2A. Pay attention to the characteristics of the LED tape.',
    'safety_2' => 'Signaling',
    'safety_3' => 'Select alarm operation mode',
    'safety_4' => 'status',
    'safety_5' => 'Window',
    'safety_6' => 'Electric drive for windows',
    'safety_7' => 'PIR sensors',
    'security' => 'Safety control',
    'send' => 'Send',
    'servo' => 'Servo',
    'servo_desc_1' => 'In this experiment user is allowed to control servo. It is controlled through digital pin. Servo got 3 pins: vcc, ground and control pin.',
    'servo_desc_2' => 'Program is using Servo.h library, which contains Servo class implementation. It is used to communicate with motor. Servo object is created on the beginning of the code. The code consists of setup and loop functions. Setup is called only once when board powers on. In this function servo is attached to pin 9 by calling attach metod of Servo object. Loop function is called continuously during all the work time of the board. In this function all the work is done. To set position of the servo method write is used. Angle is passed to the method as parameter. Function delay is halt board’s work for desirable time in milliseconds. It is necessary to give the servo time to perform turn before next command is given. Not all servos got turning range of 0-180 degrees. It may vary depending on model.',
    'servo_desc_3' => 'Servo continuously receives commands to turn between two positions. Two seconds delay is made to give servo time to turn.',
    'servo_desc_4' => 'In this case smooth turns are performed. To achieve that servo changes position by one degree each 15 milliseconds in for loop.',
    'servo_example_1' => 'Two position turns',
    'servo_example_2' => 'Smooth turns',
    'sh' => 'Smart House & IoT',
    'simpl' => 'Accessibility',
    'simpl_desc' => 'Use our hardware instead of spending money',
    'slide1' => 'Registration',
    'slide1_button' => 'Sign up today',
    'slide1_desc' => 'To get access to remote experiments it is necessary to be registered.',
    'slide2' => 'Students\' project',
    'slide2_desc' => 'Project of master and post-graduate students of Software Tools Department of Zaporizhzhya National Technical University.',
    'slide3' => 'Embedded systems',
    'slide3_desc' => 'Embedded systems today rules the world. Use the laboratory for rapid prototyping of embedded system.',
    'sname' => 'second name',
    'solar_1' => 'The experiment allows studying the principles of solar energy obtaining and accumulating. Also, the experiment demonstrates the typical scheme for organizing of the process of energy accumulation in batteries.',
    'solar_10' => 'Solar panel',
    'solar_11' => 'Solar charge controller',
    'solar_12' => 'Inverter',
    'solar_13' => 'Accumulators',
    'solar_2' => 'During the experiment, it is possible to trace the change of the voltage produced by the solar panel when the illumination intensity is changed. For the holding of the experiment, turn on the lighting and analyze the changes on the graph.',
    'solar_3' => 'Arduino Nano V3 (5V)',
    'solar_4' => 'Solar panel (6V, 250mA)',
    'solar_5' => 'Resistive divider (1/2)',
    'solar_6' => 'Charge Controller (TP4056)',
    'solar_7' => 'Accumulator (3.7V, 1100mA)',
    'solar_8' => 'Turn on/off light',
    'solar_9' => 'Solar station voltage(V)',
    'solar_station' => 'Solar station',
    'start' => 'Start',
    'startTime' => 'Start',
    'stat' => 'Statistics',
    'stud' => 'student',
    'target' => 'Target audience',
    'target_desc' => 'Students, teachers and developers in the field of embedded systems design.',
    'theme' => 'Theme',
    'titlename' => 'RELDES',
    'to_top' => 'Back to top',
    'tpc' => 'Typical program code',
    'univer' => 'ZNTU',
    'uno_extra' => 'Specification',
    'uno_extra_desc' => '<div class="spoiler-body collapse"> <h4>Power</h4> <p> The Arduino Uno can be powered via the USB connection or with an external power supply. The power source is selected automatically. </p> <p> External (non-USB) power can come either from an AC-to-DC adapter (wall-wart) or battery. The adapter can be connected by plugging a 2.1mm center-positive plug into the board\'s power jack. Leads from a battery can be inserted in the Gnd and Vin pin headers of the POWER connector. </p> <p> The board can operate on an external supply of 6 to 20 volts. If supplied with less than 7V, however, the 5V pin may supply less than five volts and the board may be unstable. If using more than 12V, the voltage regulator may overheat and damage the board. The recommended range is 7 to 12 volts. </p> <p> The power pins are as follows: <ul> <li><strong>VIN.</strong> The input voltage to the Arduino board when it\'s using an external power source (as opposed to 5 volts from the USB connection or other regulated power source). You can supply voltage through this pin, or, if supplying voltage via the power jack, access it through this pin.</li> <li><strong>5V.</strong> This pin outputs a regulated 5V from the regulator on the board. The board can be supplied with power either from the DC power jack (7 - 12V), the USB connector (5V), or the VIN pin of the board (7-12V). Supplying voltage via the 5V or 3.3V pins bypasses the regulator, and can damage your board. We don\'t advise it.</li> <li><strong>3V3.</strong> A 3.3 volt supply generated by the on-board regulator. Maximum current draw is 50 mA.</li> <li><strong>GND.</strong> Ground pins.</li> <li><strong>IOREF.</strong> This pin on the Arduino board provides the voltage reference with which the microcontroller operates. A properly configured shield can read the IOREF pin voltage and select the appropriate power source or enable voltage translators on the outputs for working with the 5V or 3.3V.</li> </ul> </p> <h4>Memory</h4> <p> The ATmega328 has 32 KB (with 0.5 KB used for the bootloader). It also has 2 KB of SRAM and 1 KB of EEPROM (which can be read and written with the EEPROM library). </p> <h4>Input and Output</h4> <p> Each of the 14 digital pins on the Uno can be used as an input or output, using pinMode(), digitalWrite(), and digitalRead() functions. They operate at 5 volts. Each pin can provide or receive a maximum of 40 mA and has an internal pull-up resistor (disconnected by default) of 20-50 kOhms. In addition, some pins have specialized functions: <ul> <li><strong>Serial: 0 (RX) and 1 (TX).</strong> Used to receive (RX) and transmit (TX) TTL serial data. These pins are connected to the corresponding pins of the ATmega8U2 USB-to-TTL Serial chip.</li> <li><strong>External Interrupts: 2 and 3.</strong> These pins can be configured to trigger an interrupt on a low value, a rising or falling edge, or a change in value. See the attachInterrupt() function for details.</li> <li><strong>PWM: 3, 5, 6, 9, 10, and 11.</strong> Provide 8-bit PWM output with the analogWrite() function.</li> <li><strong>SPI: 10 (SS), 11 (MOSI), 12 (MISO), 13 (SCK).</strong> These pins support SPI communication using the SPI library.</li> <li><strong>LED: 13.</strong> There is a built-in LED connected to digital pin 13. When the pin is HIGH value, the LED is on, when the pin is LOW, it\'s off.</li> <li><strong>TWI: A4 or SDA pin and A5 or SCL pin.</strong> Support TWI communication using the Wire library.</li> </ul> <p> The Uno has 6 analog inputs, labeled A0 through A5, each of which provide 10 bits of resolution (i.e. 1024 different values). By default they measure from ground to 5 volts, though is it possible to change the upper end of their range using the AREF pin and the analogReference() function. </p> <p> There are a couple of other pins on the board: <ul> <li><strong>AREF.</strong> Reference voltage for the analog inputs. Used with analogReference().</li> <li><strong>Reset.</strong> Bring this line LOW to reset the microcontroller. Typically used to add a reset button to shields which block the one on the board.</li> </ul> </p> <h4>Communication</h4> <p> The Arduino Uno has a number of facilities for communicating with a computer, another Arduino, or other microcontrollers. The ATmega328 provides UART TTL (5V) serial communication, which is available on digital pins 0 (RX) and 1 (TX). An ATmega16U2 on the board channels this serial communication over USB and appears as a virtual com port to software on the computer. The \'16U2 firmware uses the standard USB COM drivers, and no external driver is needed. However, on Windows, a .inf file is required. The Arduino software includes a serial monitor which allows simple textual data to be sent to and from the Arduino board. The RX and TX LEDs on the board will flash when data is being transmitted via the USB-to-serial chip and USB connection to the computer (but not for serial communication on pins 0 and 1). </p> <p> A SoftwareSerial library allows for serial communication on any of the Uno\'s digital pins. </p> <p> The ATmega328 also supports I2C (TWI) and SPI communication. The Arduino software includes a Wire library to simplify use of the I2C bus; see the documentation for details. For SPI communication, use the SPI library. </p> <h4>Programming</h4> <p> The Arduino Uno can be programmed with the Arduino software (download). Select Arduino Uno from the Tools > Board menu (according to the microcontroller on your board). For details, see the reference and tutorials. </p> <p> The ATmega328 on the Arduino Uno comes preburned with a bootloader that allows you to upload new code to it without the use of an external hardware programmer. It communicates using the original STK500 protocol. </p> <p> You can also bypass the bootloader and program the microcontroller through the ICSP (In-Circuit Serial Programming) header using Arduino ISP or similar. </p> <p> The ATmega16U2 (or 8U2 in the rev1 and rev2 boards) firmware source code is available . The ATmega16U2/8U2 is loaded with a DFU bootloader. You can then use Atmel\'s FLIP software (Windows) or the DFU programmer (Mac OS X and Linux) to load a new firmware. Or you can use the ISP header with an external programmer (overwriting the DFU bootloader). See this user-contributed tutorial for more information. </p> <h4>Automatic (Software) Reset</h4> <p> Rather than requiring a physical press of the reset button before an upload, the Arduino Uno is designed in a way that allows it to be reset by software running on a connected computer. One of the hardware flow control lines (DTR) of the ATmega8U2/16U2 is connected to the reset line of the ATmega328 via a 100 nanofarad capacitor. When this line is asserted (taken low), the reset line drops long enough to reset the chip. The Arduino software uses this capability to allow you to upload code by simply pressing the upload button in the Arduino environment. This means that the bootloader can have a shorter timeout, as the lowering of DTR can be well-coordinated with the start of the upload. </p> <p> This setup has other implications. When the Uno is connected to either a computer running Mac OS X or Linux, it resets each time a connection is made to it from software (via USB). For the following half-second or so, the bootloader is running on the Uno. While it is programmed to ignore malformed data (i.e. anything besides an upload of new code), it will intercept the first few bytes of data sent to the board after a connection is opened. If a sketch running on the board receives one-time configuration or other data when it first starts, make sure that the software with which it communicates waits a second after opening the connection and before sending this data. </p> <p> The Uno contains a trace that can be cut to disable the auto-reset. The pads on either side of the trace can be soldered together to re-enable it. It\'s labeled "RESET-EN". You may also be able to disable the auto-reset by connecting a 110 ohm resistor from 5V to the reset line. </p> <h4>USB Overcurrent Protection</h4> <p> The Arduino Uno has a resettable polyfuse that protects your computer\'s USB ports from shorts and overcurrent. Although most computers provide their own internal protection, the fuse provides an extra layer of protection. If more than 500 mA is applied to the USB port, the fuse will automatically break the connection until the short or overload is removed. </p> <h4>Physical Characteristics</h4> <p> The maximum length and width of the Uno PCB are 2.7 and 2.1 inches respectively, with the USB connector and power jack extending beyond the former dimension. Four screw holes allow the board to be attached to a surface or case. Note that the distance between digital pins 7 and 8 is 160 mil (0.16"), not an even multiple of the 100 mil spacing of the other pins. </p> </div>',
    'uno_info' => 'Overview',
    'uno_info_desc' => 'The Arduino Uno is a microcontroller board based on the ATmega328 (<a target=\'_blank\' href=\'http://www.atmel.com/Images/doc8161.pdf\'>datasheet, pdf</a>). It has 14 digital input/output pins (of which 6 can be used as PWM outputs), 6 analog inputs, a 16 MHz ceramic resonator, a USB connection, a power jack, an ICSP header, and a reset button. It contains everything needed to support the microcontroller; simply connect it to a computer with a USB cable or power it with a AC-to-DC adapter or battery to get started.',
    'uno_summary' => '<tr><td>Microcontroller</td><td>ATmega328</td></tr> <tr><td>Operating Voltage</td><td>5V</td></tr> <tr><td>Input Voltage (recommended)</td><td>7-12V</td></tr> <tr><td>Input Voltage (limits)</td><td>6-20V</td></tr> <tr><td>Digital I/O Pins</td><td>14 (of which 6 provide PWM output)</td></tr> <tr><td>Analog Input Pins</td><td>6</td></tr> <tr><td>DC Current per I/O Pin</td><td>40 mA</td></tr> <tr><td>DC Current for 3.3V Pin</td><td>50 mA</td></tr> <tr><td>Flash Memory</td><td>32 KB of which 0.5 KB used by bootloader</td></tr> <tr><td>SRAM</td><td>2 KB</td></tr> <tr><td>EEPROM</td><td>1 KB</td></tr> <tr><td>Clock Speed</td><td>16 MHz</td></tr>',
    'upload' => 'Upload',
    'usage' => 'Using experiments',
    'vent_1' => 'The experiment demonstrates the principles of ventilation system constructing with air flow speed controlling and air heating for heating the rooms.',
    'vent_10' => 'Recuperator unit',
    'vent_11' => 'Inside recuperator construction',
    'vent_12' => 'Air heating unit',
    'vent_2' => 'Arduino Nano generates a wide-pulse signal for the L298 load driver thereby controlling the fan speed. Also, Arduino Nano controls the Peltier element by the means of relay module for air heating. DHT22 sensor controls the temperature and humidity in the room.',
    'vent_3' => 'L298 Load Management Driver',
    'vent_4' => 'Relay 5V',
    'vent_5' => 'Element of Peltier',
    'vent_6' => 'Temperature and humidity sensor DHT22',
    'vent_7' => 'To conduct the experiment, drag the slider to the desired position, thereby adjusting the speed of the fan in the ventilation system. Turn on the air heating and analyze the results on the graph. Control the fan speed and analyze the results on the graph.',
    'vent_8' => 'Turn on\\off heating',
    'vent_9' => 'Recuperator',
    'ventilation' => 'Ventilation',
    'virtual_model' => 'Virtual model',
    'vritual_model_error' => 'Currently virtual model not supported on mobile devices',
    'wireless' => 'Cyber-security',
    'zone' => 'Zone control',
    'zone_1' => 'The experiment allows studying the principles of security systems creation based on lasers. It gives possibilities of realization of invisible controlled barriers for specific zones.',
    'zone_2' => 'The experiment was created for studying the operation and construction of perimeter control systems based on the source of the laser transmitter and receiver. These systems allow to control a certain area using a very thin laser with a long working distance. Laser reflectors are often used in such systems.',
    'zone_3' => 'Laser Module',
    'zone_4' => 'Light Sensor',
    'zone_5' => 'Turn on perimeter control and simulate the crossing of the perimeter by opening the garage door. Review the result of turning on the light alarm in the experiment window.',
    'zone_6' => 'Turn on/off perimeter control',
    'zone_7' => 'Crossing the perimeter',
    'zone_8' => 'Infrared perimeter example',
];
?>
